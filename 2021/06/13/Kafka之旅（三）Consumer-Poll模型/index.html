<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">
<meta name="referrer" content="same-origin">
<meta name="referrer" content="no-referrer" />








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Kafka," />










<meta name="description" content="&amp;emsp;&amp;emsp;KafkaConsumer#poll是我们消费消息的核心逻辑所在，从某种意义上来说理解了Kafka的poll模型才能真正用好Kafka Consumer，poll代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public Consum">
<meta name="keywords" content="Kafka">
<meta property="og:type" content="article">
<meta property="og:title" content="Kafka之旅（三）Consumer-Poll模型">
<meta property="og:url" content="http://functm.com/2021/06/13/Kafka之旅（三）Consumer-Poll模型/index.html">
<meta property="og:site_name" content="矩阵编程">
<meta property="og:description" content="&amp;emsp;&amp;emsp;KafkaConsumer#poll是我们消费消息的核心逻辑所在，从某种意义上来说理解了Kafka的poll模型才能真正用好Kafka Consumer，poll代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public Consum">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2021-06-13T14:11:05.676Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kafka之旅（三）Consumer-Poll模型">
<meta name="twitter:description" content="&amp;emsp;&amp;emsp;KafkaConsumer#poll是我们消费消息的核心逻辑所在，从某种意义上来说理解了Kafka的poll模型才能真正用好Kafka Consumer，poll代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public Consum">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://functm.com/2021/06/13/Kafka之旅（三）Consumer-Poll模型/"/>





  <title>Kafka之旅（三）Consumer-Poll模型 | 矩阵编程</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?7d29e6fba8e07d1a8af2414a20e5f2a6";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">矩阵编程</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-主页">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-主页"></i> <br />
            
            主页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-分类"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-所有文章">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-文章"></i> <br />
            
            所有文章
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://functm.com/2021/06/13/Kafka之旅（三）Consumer-Poll模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="functm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="矩阵编程">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Kafka之旅（三）Consumer-Poll模型</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-06-13T22:11:05+08:00">
                2021-06-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kafka/" itemprop="url" rel="index">
                    <span itemprop="name">Kafka</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/06/13/Kafka之旅（三）Consumer-Poll模型/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2021/06/13/Kafka之旅（三）Consumer-Poll模型/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>&emsp;&emsp;<strong>KafkaConsumer#poll</strong>是我们消费消息的核心逻辑所在，从某种意义上来说理解了Kafka的poll模型才能真正用好Kafka Consumer，poll代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConsumerRecords&lt;K, V&gt; <span class="title">poll</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> timeoutMs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> poll(time.timer(timeoutMs), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ConsumerRecords&lt;K, V&gt; <span class="title">poll</span><span class="params">(<span class="keyword">final</span> Duration timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> poll(time.timer(timeout), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> ConsumerRecords&lt;K, V&gt; <span class="title">poll</span><span class="params">(<span class="keyword">final</span> Timer timer, <span class="keyword">final</span> <span class="keyword">boolean</span> includeMetadataInTimeout)</span> </span>&#123;</span><br><span class="line">    acquireAndEnsureOpen();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.kafkaConsumerMetrics.recordPollStart(timer.currentTimeMs());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.subscriptions.hasNoSubscriptionOrUserAssignment()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Consumer is not subscribed to any topics or assigned any partitions"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            client.maybeTriggerWakeup();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (includeMetadataInTimeout) &#123;</span><br><span class="line">                <span class="comment">// try to update assignment metadata BUT do not need to block on the timer for join group</span></span><br><span class="line">                updateAssignmentMetadataIfNeeded(timer, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!updateAssignmentMetadataIfNeeded(time.timer(Long.MAX_VALUE), <span class="keyword">true</span>)) &#123;</span><br><span class="line">                    log.warn(<span class="string">"Still waiting for metadata"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records = pollForFetches(timer);</span><br><span class="line">            <span class="keyword">if</span> (!records.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// before returning the fetched records, we can send off the next round of fetches</span></span><br><span class="line">                <span class="comment">// and avoid block waiting for their responses to enable pipelining while the user</span></span><br><span class="line">                <span class="comment">// is handling the fetched records.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// <span class="doctag">NOTE:</span> since the consumed position has already been updated, we must not allow</span></span><br><span class="line">                <span class="comment">// wakeups or any other errors to be triggered prior to returning the fetched records.</span></span><br><span class="line">                <span class="keyword">if</span> (fetcher.sendFetches() &gt; <span class="number">0</span> || client.hasPendingRequests()) &#123;</span><br><span class="line">                    client.transmitSends();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.interceptors.onConsume(<span class="keyword">new</span> ConsumerRecords&lt;&gt;(records));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (timer.notExpired());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ConsumerRecords.empty();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        release();</span><br><span class="line">        <span class="keyword">this</span>.kafkaConsumerMetrics.recordPollEnd(timer.currentTimeMs());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<ol>
<li>poll主要有两种方式，看上去两个方法神似，一样的timeout参数命名，而且其实底层调用的方法都一样，唯一的区别是<strong>includeMetadataInTimeout</strong>参数。<strong>includeMetadataInTimeout=True</strong>表示获取消息的超时时间是否包含了获取元数据的时间，使用的时候需要注意。</li>
<li>整个poll流程大致分两步走：<strong>updateAssignmentMetadataIfNeeded</strong>更新分区的元数据信息和<strong>pollForFetches</strong>拉取数据。</li>
</ol>
<p>简单看一下<strong>KafkaConsumer#updateAssignmentMetadataIfNeeded</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">updateAssignmentMetadataIfNeeded</span><span class="params">(<span class="keyword">final</span> Timer timer, <span class="keyword">final</span> <span class="keyword">boolean</span> waitForJoinGroup)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (coordinator != <span class="keyword">null</span> &amp;&amp; !coordinator.poll(timer, waitForJoinGroup)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> updateFetchPositions(timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用<strong>ConsumerCoordinator#poll</strong>，<strong>ConsumerCoordinator</strong>和服务端<strong>GroupCoordinator</strong>紧密结合，负责 consumer group 成员变更、rebalance以及offset管理等。<strong>ConsumerCoordinator</strong>这一部分的代码留待后面再说，下面着重看一下poll的主流程，<strong>KafkaConsumer#pollForFetches</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; pollForFetches(Timer timer) &#123;</span><br><span class="line">    <span class="keyword">long</span> pollTimeout = coordinator == <span class="keyword">null</span> ? timer.remainingMs() :</span><br><span class="line">            Math.min(coordinator.timeToNextPoll(timer.currentTimeMs()), timer.remainingMs());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if data is available already, return it immediately</span></span><br><span class="line">    <span class="keyword">final</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records = fetcher.fetchedRecords();</span><br><span class="line">    <span class="keyword">if</span> (!records.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> records;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send any new fetches (won't resend pending fetches)</span></span><br><span class="line">    fetcher.sendFetches();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We do not want to be stuck blocking in poll if we are missing some positions</span></span><br><span class="line">    <span class="comment">// since the offset lookup may be backing off after a failure</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> the use of cachedSubscriptionHashAllFetchPositions means we MUST call</span></span><br><span class="line">    <span class="comment">// updateAssignmentMetadataIfNeeded before this method.</span></span><br><span class="line">    <span class="keyword">if</span> (!cachedSubscriptionHashAllFetchPositions &amp;&amp; pollTimeout &gt; retryBackoffMs) &#123;</span><br><span class="line">        pollTimeout = retryBackoffMs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Timer pollTimer = time.timer(pollTimeout);</span><br><span class="line">    client.poll(pollTimer, () -&gt; &#123;</span><br><span class="line">        <span class="comment">// since a fetch might be completed by the background thread, we need this poll condition</span></span><br><span class="line">        <span class="comment">// to ensure that we do not block unnecessarily in poll()</span></span><br><span class="line">        <span class="keyword">return</span> !fetcher.hasAvailableFetches();</span><br><span class="line">    &#125;);</span><br><span class="line">    timer.update(pollTimer.currentTimeMs());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fetcher.fetchedRecords();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><strong>Fetcher#fetchedRecords</strong> 如果已经获取到数据，马上返回；否则调用<strong>Fetcher#sendFetches</strong>发送获取数据的请求。</li>
<li><strong>ConsumerNetworkClient#poll</strong> 发送请求获取数据，如果有请求已经返回了，这里就不会阻塞；否则会进行阻塞（根据超时时间而定）。</li>
<li>最后再执行一遍<strong>Fetcher#fetchedRecords</strong>获取数据。</li>
</ol>
<p>从上面的代码分析，KafkaConsumer poll的重点在于<strong>Fetcher</strong>以及<strong>ConsumerNetworkClient</strong>，下面分布看一下这两个类做了什么。先看一下<strong>Fetcher#sendFetches</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">sendFetches</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Update metrics in case there was an assignment change</span></span><br><span class="line">        sensors.maybeUpdateAssignment(subscriptions);</span><br><span class="line"></span><br><span class="line">        Map&lt;Node, FetchSessionHandler.FetchRequestData&gt; fetchRequestMap = prepareFetchRequests();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Node, FetchSessionHandler.FetchRequestData&gt; entry : fetchRequestMap.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node fetchTarget = entry.getKey();</span><br><span class="line">            <span class="keyword">final</span> FetchSessionHandler.FetchRequestData data = entry.getValue();</span><br><span class="line">            <span class="keyword">final</span> FetchRequest.Builder request = FetchRequest.Builder</span><br><span class="line">                    .forConsumer(<span class="keyword">this</span>.maxWaitMs, <span class="keyword">this</span>.minBytes, data.toSend())</span><br><span class="line">                    .isolationLevel(isolationLevel)</span><br><span class="line">                    .setMaxBytes(<span class="keyword">this</span>.maxBytes)</span><br><span class="line">                    .metadata(data.metadata())</span><br><span class="line">                    .toForget(data.toForget())</span><br><span class="line">                    .rackId(clientRackId);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                log.debug(<span class="string">"Sending &#123;&#125; &#123;&#125; to broker &#123;&#125;"</span>, isolationLevel, data.toString(), fetchTarget);</span><br><span class="line">            &#125;</span><br><span class="line">            RequestFuture&lt;ClientResponse&gt; future = client.send(fetchTarget, request);</span><br><span class="line">            <span class="comment">// We add the node to the set of nodes with pending fetch requests before adding the</span></span><br><span class="line">            <span class="comment">// listener because the future may have been fulfilled on another thread (e.g. during a</span></span><br><span class="line">            <span class="comment">// disconnection being handled by the heartbeat thread) which will mean the listener</span></span><br><span class="line">            <span class="comment">// will be invoked synchronously.</span></span><br><span class="line">            <span class="keyword">this</span>.nodesWithPendingFetchRequests.add(entry.getKey().id());</span><br><span class="line">            future.addListener(<span class="keyword">new</span> RequestFutureListener&lt;ClientResponse&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(ClientResponse resp)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (Fetcher.<span class="keyword">this</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                            FetchResponse&lt;Records&gt; response = (FetchResponse&lt;Records&gt;) resp.responseBody();</span><br><span class="line">                            FetchSessionHandler handler = sessionHandler(fetchTarget.id());</span><br><span class="line">                            <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                log.error(<span class="string">"Unable to find FetchSessionHandler for node &#123;&#125;. Ignoring fetch response."</span>,</span><br><span class="line">                                        fetchTarget.id());</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (!handler.handleResponse(response)) &#123;</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            Set&lt;TopicPartition&gt; partitions = <span class="keyword">new</span> HashSet&lt;&gt;(response.responseData().keySet());</span><br><span class="line">                            FetchResponseMetricAggregator metricAggregator = <span class="keyword">new</span> FetchResponseMetricAggregator(sensors, partitions);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">for</span> (Map.Entry&lt;TopicPartition, FetchResponse.PartitionData&lt;Records&gt;&gt; entry : response.responseData().entrySet()) &#123;</span><br><span class="line">                                TopicPartition partition = entry.getKey();</span><br><span class="line">                                FetchRequest.PartitionData requestData = data.sessionPartitions().get(partition);</span><br><span class="line">                                <span class="keyword">if</span> (requestData == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    String message;</span><br><span class="line">                                    <span class="keyword">if</span> (data.metadata().isFull()) &#123;</span><br><span class="line">                                        message = MessageFormatter.arrayFormat(</span><br><span class="line">                                                <span class="string">"Response for missing full request partition: partition=&#123;&#125;; metadata=&#123;&#125;"</span>,</span><br><span class="line">                                                <span class="keyword">new</span> Object[]&#123;partition, data.metadata()&#125;).getMessage();</span><br><span class="line">                                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        message = MessageFormatter.arrayFormat(</span><br><span class="line">                                                <span class="string">"Response for missing session request partition: partition=&#123;&#125;; metadata=&#123;&#125;; toSend=&#123;&#125;; toForget=&#123;&#125;"</span>,</span><br><span class="line">                                                <span class="keyword">new</span> Object[]&#123;partition, data.metadata(), data.toSend(), data.toForget()&#125;).getMessage();</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// Received fetch response for missing session partition</span></span><br><span class="line">                                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(message);</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">long</span> fetchOffset = requestData.fetchOffset;</span><br><span class="line">                                    FetchResponse.PartitionData&lt;Records&gt; partitionData = entry.getValue();</span><br><span class="line"></span><br><span class="line">                                    log.debug(<span class="string">"Fetch &#123;&#125; at offset &#123;&#125; for partition &#123;&#125; returned fetch data &#123;&#125;"</span>,</span><br><span class="line">                                            isolationLevel, fetchOffset, partition, partitionData);</span><br><span class="line"></span><br><span class="line">                                    Iterator&lt;? extends RecordBatch&gt; batches = partitionData.records.batches().iterator();</span><br><span class="line">                                    <span class="keyword">short</span> responseVersion = resp.requestHeader().apiVersion();</span><br><span class="line"></span><br><span class="line">                                    completedFetches.add(<span class="keyword">new</span> CompletedFetch(partition, partitionData,</span><br><span class="line">                                            metricAggregator, batches, fetchOffset, responseVersion));</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            sensors.fetchLatency.record(resp.requestLatencyMs());</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            nodesWithPendingFetchRequests.remove(fetchTarget.id());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(RuntimeException e)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (Fetcher.<span class="keyword">this</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            FetchSessionHandler handler = sessionHandler(fetchTarget.id());</span><br><span class="line">                            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                handler.handleError(e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            nodesWithPendingFetchRequests.remove(fetchTarget.id());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fetchRequestMap.size();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>先看一下<strong>Fetcher#fetchedRecords</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; fetchedRecords() &#123;</span><br><span class="line">     Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; fetched = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">     Queue&lt;CompletedFetch&gt; pausedCompletedFetches = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">     <span class="keyword">int</span> recordsRemaining = maxPollRecords;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">while</span> (recordsRemaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (nextInLineFetch == <span class="keyword">null</span> || nextInLineFetch.isConsumed) &#123;</span><br><span class="line">                 CompletedFetch records = completedFetches.peek();</span><br><span class="line">                 <span class="keyword">if</span> (records == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">if</span> (records.notInitialized()) &#123;</span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                         nextInLineFetch = initializeCompletedFetch(records);</span><br><span class="line">                     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                         <span class="comment">// Remove a completedFetch upon a parse with exception if (1) it contains no records, and</span></span><br><span class="line">                         <span class="comment">// (2) there are no fetched records with actual content preceding this exception.</span></span><br><span class="line">                         <span class="comment">// The first condition ensures that the completedFetches is not stuck with the same completedFetch</span></span><br><span class="line">                         <span class="comment">// in cases such as the TopicAuthorizationException, and the second condition ensures that no</span></span><br><span class="line">                         <span class="comment">// potential data loss due to an exception in a following record.</span></span><br><span class="line">                         FetchResponse.PartitionData partition = records.partitionData;</span><br><span class="line">                         <span class="keyword">if</span> (fetched.isEmpty() &amp;&amp; (partition.records == <span class="keyword">null</span> || partition.records.sizeInBytes() == <span class="number">0</span>)) &#123;</span><br><span class="line">                             completedFetches.poll();</span><br><span class="line">                         &#125;</span><br><span class="line">                         <span class="keyword">throw</span> e;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     nextInLineFetch = records;</span><br><span class="line">                 &#125;</span><br><span class="line">                 completedFetches.poll();</span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subscriptions.isPaused(nextInLineFetch.partition)) &#123;</span><br><span class="line">                 <span class="comment">// when the partition is paused we add the records back to the completedFetches queue instead of draining</span></span><br><span class="line">                 <span class="comment">// them so that they can be returned on a subsequent poll if the partition is resumed at that time</span></span><br><span class="line">                 log.debug(<span class="string">"Skipping fetching records for assigned partition &#123;&#125; because it is paused"</span>, nextInLineFetch.partition);</span><br><span class="line">                 pausedCompletedFetches.add(nextInLineFetch);</span><br><span class="line">                 nextInLineFetch = <span class="keyword">null</span>;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 List&lt;ConsumerRecord&lt;K, V&gt;&gt; records = fetchRecords(nextInLineFetch, recordsRemaining);</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">if</span> (!records.isEmpty()) &#123;</span><br><span class="line">                     TopicPartition partition = nextInLineFetch.partition;</span><br><span class="line">                     List&lt;ConsumerRecord&lt;K, V&gt;&gt; currentRecords = fetched.get(partition);</span><br><span class="line">                     <span class="keyword">if</span> (currentRecords == <span class="keyword">null</span>) &#123;</span><br><span class="line">                         fetched.put(partition, records);</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                         <span class="comment">// this case shouldn't usually happen because we only send one fetch at a time per partition,</span></span><br><span class="line">                         <span class="comment">// but it might conceivably happen in some rare cases (such as partition leader changes).</span></span><br><span class="line">                         <span class="comment">// we have to copy to a new list because the old one may be immutable</span></span><br><span class="line">                         List&lt;ConsumerRecord&lt;K, V&gt;&gt; newRecords = <span class="keyword">new</span> ArrayList&lt;&gt;(records.size() + currentRecords.size());</span><br><span class="line">                         newRecords.addAll(currentRecords);</span><br><span class="line">                         newRecords.addAll(records);</span><br><span class="line">                         fetched.put(partition, newRecords);</span><br><span class="line">                     &#125;</span><br><span class="line">                     recordsRemaining -= records.size();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (KafkaException e) &#123;</span><br><span class="line">         <span class="keyword">if</span> (fetched.isEmpty())</span><br><span class="line">             <span class="keyword">throw</span> e;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// add any polled completed fetches for paused partitions back to the completed fetches queue to be</span></span><br><span class="line">         <span class="comment">// re-evaluated in the next poll</span></span><br><span class="line">         completedFetches.addAll(pausedCompletedFetches);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> fetched;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>此方法处在一个循环内，直到获取的数量达到设定的<strong>max.poll.records</strong>（poll操作返回的最大记录数）</li>
<li>nextInLineFetch（CompletedFetch）实例为空或者其属性isConsumed=true，则尝试从completedFetches（ConcurrentLinkedQueue<completedfetch>）队列中获取一个CompletedFetch并尝试初始化。<strong>CompletedFetch</strong>是已完成请求的封装，包含本次请求的分区以及获取到的一些数据记录等。</completedfetch></li>
<li>判断订阅分区状态，如果isPaused则将该CompletedFetch先挂起（处理完成最后会重新丢入completedFetches）。</li>
<li><p>处理CompletedFetch的地方重点还要看<strong>Fetcher#fetchRecords(CompletedFetch completedFetch, int maxRecords)</strong>：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;ConsumerRecord&lt;K, V&gt;&gt; fetchRecords(CompletedFetch completedFetch, <span class="keyword">int</span> maxRecords) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!subscriptions.isAssigned(completedFetch.partition)) &#123;</span><br><span class="line">        <span class="comment">// this can happen when a rebalance happened before fetched records are returned to the consumer's poll call</span></span><br><span class="line">        log.debug(<span class="string">"Not returning fetched records for partition &#123;&#125; since it is no longer assigned"</span>,</span><br><span class="line">                completedFetch.partition);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!subscriptions.isFetchable(completedFetch.partition)) &#123;</span><br><span class="line">        <span class="comment">// this can happen when a partition is paused before fetched records are returned to the consumer's</span></span><br><span class="line">        <span class="comment">// poll call or if the offset is being reset</span></span><br><span class="line">        log.debug(<span class="string">"Not returning fetched records for assigned partition &#123;&#125; since it is no longer fetchable"</span>,</span><br><span class="line">                completedFetch.partition);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        FetchPosition position = subscriptions.position(completedFetch.partition);</span><br><span class="line">        <span class="keyword">if</span> (position == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Missing position for fetchable partition "</span> + completedFetch.partition);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (completedFetch.nextFetchOffset == position.offset) &#123;</span><br><span class="line">            List&lt;ConsumerRecord&lt;K, V&gt;&gt; partRecords = completedFetch.fetchRecords(maxRecords);</span><br><span class="line"></span><br><span class="line">            log.trace(<span class="string">"Returning &#123;&#125; fetched records at offset &#123;&#125; for assigned partition &#123;&#125;"</span>,</span><br><span class="line">                    partRecords.size(), position, completedFetch.partition);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (completedFetch.nextFetchOffset &gt; position.offset) &#123;</span><br><span class="line">                FetchPosition nextPosition = <span class="keyword">new</span> FetchPosition(</span><br><span class="line">                        completedFetch.nextFetchOffset,</span><br><span class="line">                        completedFetch.lastEpoch,</span><br><span class="line">                        position.currentLeader);</span><br><span class="line">                log.trace(<span class="string">"Update fetching position to &#123;&#125; for partition &#123;&#125;"</span>, nextPosition, completedFetch.partition);</span><br><span class="line">                subscriptions.position(completedFetch.partition, nextPosition);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Long partitionLag = subscriptions.partitionLag(completedFetch.partition, isolationLevel);</span><br><span class="line">            <span class="keyword">if</span> (partitionLag != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">this</span>.sensors.recordPartitionLag(completedFetch.partition, partitionLag);</span><br><span class="line"></span><br><span class="line">            Long lead = subscriptions.partitionLead(completedFetch.partition);</span><br><span class="line">            <span class="keyword">if</span> (lead != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.sensors.recordPartitionLead(completedFetch.partition, lead);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> partRecords;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// these records aren't next in line based on the last consumed position, ignore them</span></span><br><span class="line">            <span class="comment">// they must be from an obsolete request</span></span><br><span class="line">            log.debug(<span class="string">"Ignoring fetched records for &#123;&#125; at offset &#123;&#125; since the current position is &#123;&#125;"</span>,</span><br><span class="line">                    completedFetch.partition, completedFetch.nextFetchOffset, position);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.trace(<span class="string">"Draining fetched records for partition &#123;&#125;"</span>, completedFetch.partition);</span><br><span class="line">    completedFetch.drain();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> emptyList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>SubscriptionState#position</strong>获取到当前的消费进度（参照PartitionStates，实际存储在其内部的一个LinkedHashMap中），调用<strong>CompletedFetch#fetchRecords</strong>获取数据并更新PartitionStates的进度，最后调用<strong>CompletedFetch#drain</strong>完成该批次消费。</li>
<li><strong>SubscriptionState#position</strong>设置当前进度，这里关系后续commit的提交。</li>
</ul>
</li>
</ol>
<p>其中<strong>CompletedFetch#fetchRecords</strong>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;ConsumerRecord&lt;K, V&gt;&gt; fetchRecords(<span class="keyword">int</span> maxRecords) &#123;</span><br><span class="line">    <span class="comment">// Error when fetching the next record before deserialization.</span></span><br><span class="line">    <span class="keyword">if</span> (corruptLastRecord)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(<span class="string">"Received exception when fetching the next record from "</span> + partition</span><br><span class="line">                                     + <span class="string">". If needed, please seek past the record to "</span></span><br><span class="line">                                     + <span class="string">"continue consumption."</span>, cachedRecordException);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isConsumed)</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line"></span><br><span class="line">    List&lt;ConsumerRecord&lt;K, V&gt;&gt; records = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxRecords; i++) &#123;</span><br><span class="line">            <span class="comment">// Only move to next record if there was no exception in the last fetch. Otherwise we should</span></span><br><span class="line">            <span class="comment">// use the last record to do deserialization again.</span></span><br><span class="line">            <span class="keyword">if</span> (cachedRecordException == <span class="keyword">null</span>) &#123;</span><br><span class="line">                corruptLastRecord = <span class="keyword">true</span>;</span><br><span class="line">                lastRecord = nextFetchedRecord();</span><br><span class="line">                corruptLastRecord = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (lastRecord == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            records.add(parseRecord(partition, currentBatch, lastRecord));</span><br><span class="line">            recordsRead++;</span><br><span class="line">            bytesRead += lastRecord.sizeInBytes();</span><br><span class="line">            nextFetchOffset = lastRecord.offset() + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// In some cases, the deserialization may have thrown an exception and the retry may succeed,</span></span><br><span class="line">            <span class="comment">// we allow user to move forward in this case.</span></span><br><span class="line">            cachedRecordException = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SerializationException se) &#123;</span><br><span class="line">        cachedRecordException = se;</span><br><span class="line">        <span class="keyword">if</span> (records.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> se;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (KafkaException e) &#123;</span><br><span class="line">        cachedRecordException = e;</span><br><span class="line">        <span class="keyword">if</span> (records.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(<span class="string">"Received exception when fetching the next record from "</span> + partition</span><br><span class="line">                                         + <span class="string">". If needed, please seek past the record to "</span></span><br><span class="line">                                         + <span class="string">"continue consumption."</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> records;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>nextFetchedRecord</strong>从CloseableIterator<record>中获取最新的record，<strong>parseRecord</strong>将该record转化为ConsumerRecord。至此整个<strong>Fetcher#fetchedRecords()</strong>完成获取数据流程，但是初始<strong>Fetcher#fetchedRecords()</strong>获取到数据肯定是空的，接下来回过头重新从<strong>KafkaConsumer#pollForFetches</strong>开始，看一下<strong>Fetcher#sendFetches</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">sendFetches</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Update metrics in case there was an assignment change</span></span><br><span class="line">    sensors.maybeUpdateAssignment(subscriptions);</span><br><span class="line"></span><br><span class="line">    Map&lt;Node, FetchSessionHandler.FetchRequestData&gt; fetchRequestMap = prepareFetchRequests();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Node, FetchSessionHandler.FetchRequestData&gt; entry : fetchRequestMap.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">final</span> Node fetchTarget = entry.getKey();</span><br><span class="line">        <span class="keyword">final</span> FetchSessionHandler.FetchRequestData data = entry.getValue();</span><br><span class="line">        <span class="keyword">final</span> FetchRequest.Builder request = FetchRequest.Builder</span><br><span class="line">                .forConsumer(<span class="keyword">this</span>.maxWaitMs, <span class="keyword">this</span>.minBytes, data.toSend())</span><br><span class="line">                .isolationLevel(isolationLevel)</span><br><span class="line">                .setMaxBytes(<span class="keyword">this</span>.maxBytes)</span><br><span class="line">                .metadata(data.metadata())</span><br><span class="line">                .toForget(data.toForget())</span><br><span class="line">                .rackId(clientRackId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">"Sending &#123;&#125; &#123;&#125; to broker &#123;&#125;"</span>, isolationLevel, data.toString(), fetchTarget);</span><br><span class="line">        &#125;</span><br><span class="line">        RequestFuture&lt;ClientResponse&gt; future = client.send(fetchTarget, request);</span><br><span class="line">        <span class="comment">// We add the node to the set of nodes with pending fetch requests before adding the</span></span><br><span class="line">        <span class="comment">// listener because the future may have been fulfilled on another thread (e.g. during a</span></span><br><span class="line">        <span class="comment">// disconnection being handled by the heartbeat thread) which will mean the listener</span></span><br><span class="line">        <span class="comment">// will be invoked synchronously.</span></span><br><span class="line">        <span class="keyword">this</span>.nodesWithPendingFetchRequests.add(entry.getKey().id());</span><br><span class="line">        future.addListener(<span class="keyword">new</span> RequestFutureListener&lt;ClientResponse&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(ClientResponse resp)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Fetcher.<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                        FetchResponse&lt;Records&gt; response = (FetchResponse&lt;Records&gt;) resp.responseBody();</span><br><span class="line">                        FetchSessionHandler handler = sessionHandler(fetchTarget.id());</span><br><span class="line">                        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            log.error(<span class="string">"Unable to find FetchSessionHandler for node &#123;&#125;. Ignoring fetch response."</span>,</span><br><span class="line">                                    fetchTarget.id());</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (!handler.handleResponse(response)) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        Set&lt;TopicPartition&gt; partitions = <span class="keyword">new</span> HashSet&lt;&gt;(response.responseData().keySet());</span><br><span class="line">                        FetchResponseMetricAggregator metricAggregator = <span class="keyword">new</span> FetchResponseMetricAggregator(sensors, partitions);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (Map.Entry&lt;TopicPartition, FetchResponse.PartitionData&lt;Records&gt;&gt; entry : response.responseData().entrySet()) &#123;</span><br><span class="line">                            TopicPartition partition = entry.getKey();</span><br><span class="line">                            FetchRequest.PartitionData requestData = data.sessionPartitions().get(partition);</span><br><span class="line">                            <span class="keyword">if</span> (requestData == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                String message;</span><br><span class="line">                                <span class="keyword">if</span> (data.metadata().isFull()) &#123;</span><br><span class="line">                                    message = MessageFormatter.arrayFormat(</span><br><span class="line">                                            <span class="string">"Response for missing full request partition: partition=&#123;&#125;; metadata=&#123;&#125;"</span>,</span><br><span class="line">                                            <span class="keyword">new</span> Object[]&#123;partition, data.metadata()&#125;).getMessage();</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    message = MessageFormatter.arrayFormat(</span><br><span class="line">                                            <span class="string">"Response for missing session request partition: partition=&#123;&#125;; metadata=&#123;&#125;; toSend=&#123;&#125;; toForget=&#123;&#125;"</span>,</span><br><span class="line">                                            <span class="keyword">new</span> Object[]&#123;partition, data.metadata(), data.toSend(), data.toForget()&#125;).getMessage();</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// Received fetch response for missing session partition</span></span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(message);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">long</span> fetchOffset = requestData.fetchOffset;</span><br><span class="line">                                FetchResponse.PartitionData&lt;Records&gt; partitionData = entry.getValue();</span><br><span class="line"></span><br><span class="line">                                log.debug(<span class="string">"Fetch &#123;&#125; at offset &#123;&#125; for partition &#123;&#125; returned fetch data &#123;&#125;"</span>,</span><br><span class="line">                                        isolationLevel, fetchOffset, partition, partitionData);</span><br><span class="line"></span><br><span class="line">                                Iterator&lt;? extends RecordBatch&gt; batches = partitionData.records.batches().iterator();</span><br><span class="line">                                <span class="keyword">short</span> responseVersion = resp.requestHeader().apiVersion();</span><br><span class="line"></span><br><span class="line">                                completedFetches.add(<span class="keyword">new</span> CompletedFetch(partition, partitionData,</span><br><span class="line">                                        metricAggregator, batches, fetchOffset, responseVersion));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        sensors.fetchLatency.record(resp.requestLatencyMs());</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        nodesWithPendingFetchRequests.remove(fetchTarget.id());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(RuntimeException e)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Fetcher.<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        FetchSessionHandler handler = sessionHandler(fetchTarget.id());</span><br><span class="line">                        <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            handler.handleError(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        nodesWithPendingFetchRequests.remove(fetchTarget.id());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fetchRequestMap.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></record></p>
<ol>
<li><strong>prepareFetchRequests()</strong>对每个节点构建请求，主要是通过<strong>ConsumerNetworkClient#send</strong>发送网络请求，然后通过<strong>RequestFutureListener</strong>作为异步回调处理请求结果。</li>
<li>先说一下<strong>RequestFutureListener</strong>处理结果的地方，主要处理返回的<strong>ClientResponse</strong>，提取数据封装成<strong>CompletedFetch</strong>并放入completedFetches（ConcurrentLinkedQueue<completedfetch>）中，等待下一次poll的时候直接从completedFetches获取数据，这个流程和上面是一致的。</completedfetch></li>
</ol>
<p>下面主要是看一下<strong>ConsumerNetworkClient#send</strong>是如何发送网络请求的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> RequestFuture&lt;ClientResponse&gt; <span class="title">send</span><span class="params">(Node node, AbstractRequest.Builder&lt;?&gt; requestBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> send(node, requestBuilder, requestTimeoutMs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RequestFuture&lt;ClientResponse&gt; <span class="title">send</span><span class="params">(Node node,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            AbstractRequest.Builder&lt;?&gt; requestBuilder,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">int</span> requestTimeoutMs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> now = time.milliseconds();</span><br><span class="line">    RequestFutureCompletionHandler completionHandler = <span class="keyword">new</span> RequestFutureCompletionHandler();</span><br><span class="line">    ClientRequest clientRequest = client.newClientRequest(node.idString(), requestBuilder, now, <span class="keyword">true</span>,</span><br><span class="line">            requestTimeoutMs, completionHandler);</span><br><span class="line">    unsent.put(node, clientRequest);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wakeup the client in case it is blocking in poll so that we can send the queued request</span></span><br><span class="line">    client.wakeup();</span><br><span class="line">    <span class="keyword">return</span> completionHandler.future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看到这个代码觉得有点熟悉，整个流程有点像<a href="/2020/12/11/Kafka之旅（一）Producer/">Kafka之旅（一）Producer</a>KafkaClient的部分，这里也仅仅是封装了<strong>RequestFutureCompletionHandler</strong>作为返回结果处理，然后将整个<strong>ClientRequest</strong>请求放入unsent（<strong>UnsentRequests</strong>，其内部维护了一个ConcurrentMap&lt;Node, ConcurrentLinkedQueue<clientrequest>&gt;节点队列），最后调用<strong>Selectable#wakeup</strong>唤醒阻塞状态的selector。那么发送网络请求的真实调用在哪里？沿着这个unsent去找最终的出口，最后发现其实是在<strong>ConsumerNetworkClient#poll</strong>这个地方：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">poll</span><span class="params">(Timer timer, PollCondition pollCondition, <span class="keyword">boolean</span> disableWakeup)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// there may be handlers which need to be invoked if we woke up the previous call to poll</span></span><br><span class="line">        firePendingCompletedRequests();</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Handle async disconnects prior to attempting any sends</span></span><br><span class="line">            handlePendingDisconnects();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// send all the requests we can send now</span></span><br><span class="line">            <span class="keyword">long</span> pollDelayMs = trySend(timer.currentTimeMs());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// check whether the poll is still needed by the caller. Note that if the expected completion</span></span><br><span class="line">            <span class="comment">// condition becomes satisfied after the call to shouldBlock() (because of a fired completion</span></span><br><span class="line">            <span class="comment">// handler), the client will be woken up.</span></span><br><span class="line">            <span class="keyword">if</span> (pendingCompletion.isEmpty() &amp;&amp; (pollCondition == <span class="keyword">null</span> || pollCondition.shouldBlock())) &#123;</span><br><span class="line">                <span class="comment">// if there are no requests in flight, do not block longer than the retry backoff</span></span><br><span class="line">                <span class="keyword">long</span> pollTimeout = Math.min(timer.remainingMs(), pollDelayMs);</span><br><span class="line">                <span class="keyword">if</span> (client.inFlightRequestCount() == <span class="number">0</span>)</span><br><span class="line">                    pollTimeout = Math.min(pollTimeout, retryBackoffMs);</span><br><span class="line">                client.poll(pollTimeout, timer.currentTimeMs());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                client.poll(<span class="number">0</span>, timer.currentTimeMs());</span><br><span class="line">            &#125;</span><br><span class="line">            timer.update();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// handle any disconnects by failing the active requests. note that disconnects must</span></span><br><span class="line">            <span class="comment">// be checked immediately following poll since any subsequent call to client.ready()</span></span><br><span class="line">            <span class="comment">// will reset the disconnect status</span></span><br><span class="line">            checkDisconnects(timer.currentTimeMs());</span><br><span class="line">            <span class="keyword">if</span> (!disableWakeup) &#123;</span><br><span class="line">                <span class="comment">// trigger wakeups after checking for disconnects so that the callbacks will be ready</span></span><br><span class="line">                <span class="comment">// to be fired on the next call to poll()</span></span><br><span class="line">                maybeTriggerWakeup();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// throw InterruptException if this thread is interrupted</span></span><br><span class="line">            maybeThrowInterruptException();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// try again to send requests since buffer space may have been</span></span><br><span class="line">            <span class="comment">// cleared or a connect finished in the poll</span></span><br><span class="line">            trySend(timer.currentTimeMs());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// fail requests that couldn't be sent if they have expired</span></span><br><span class="line">            failExpiredRequests(timer.currentTimeMs());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// clean unsent requests collection to keep the map from growing indefinitely</span></span><br><span class="line">            unsent.clean();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// called without the lock to avoid deadlock potential if handlers need to acquire locks</span></span><br><span class="line">        firePendingCompletedRequests();</span><br><span class="line"></span><br><span class="line">        metadata.maybeThrowAnyException();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></clientrequest></p>
<p><strong>ConsumerNetworkClient#trySend</strong>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">trySend</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> pollDelayMs = maxPollTimeoutMs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send any requests that can be sent now</span></span><br><span class="line">    <span class="keyword">for</span> (Node node : unsent.nodes()) &#123;</span><br><span class="line">        Iterator&lt;ClientRequest&gt; iterator = unsent.requestIterator(node);</span><br><span class="line">        <span class="keyword">if</span> (iterator.hasNext())</span><br><span class="line">            pollDelayMs = Math.min(pollDelayMs, client.pollDelayMs(node, now));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            ClientRequest request = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (client.ready(node, now)) &#123;</span><br><span class="line">                client.send(request, now);</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// try next node when current node is not ready</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pollDelayMs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>遍历unsent中的请求，然后调用KafkaClient#send发送请求，最后调用KafkaClient#poll，又看到上文熟悉的KafkaClient调用方式，不再赘述。回到<strong>KafkaConsumer#pollForFetches</strong>，最后又是调用一遍<strong>Fetcher#fetchedRecords</strong>尝试再一次处理本次请求新拿到的数据，自此整个<strong>KafkaConsumer#poll</strong>流程处理完毕。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Kafka/" rel="tag"># Kafka</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/06/13/Kafka之旅（二）Consumer订阅/" rel="next" title="Kafka之旅（二）Consumer订阅">
                <i class="fa fa-chevron-left"></i> Kafka之旅（二）Consumer订阅
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/06/13/谈CGLIB以及和JDK动态代理的对比/" rel="prev" title="谈CGLIB以及和JDK动态代理的对比">
                谈CGLIB以及和JDK动态代理的对比 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">functm</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">50</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">functm</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>
<div class=BbeiAn-info">
  浙ICP备 -
  <a href="http://www.beian.miit.gov.cn">18040498号</a>
  </a>
</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://luyun.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://functm.com/2021/06/13/Kafka之旅（三）Consumer-Poll模型/';
          this.page.identifier = '2021/06/13/Kafka之旅（三）Consumer-Poll模型/';
          this.page.title = 'Kafka之旅（三）Consumer-Poll模型';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://luyun.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  

  

  

</body>
</html>
