<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="&emsp;&emsp;KafkaConsumer#poll是我们消费消息的核心逻辑所在，从某种意义上来说理解了Kafka的poll模型才能真正用好Kafka Consumer，poll代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public Con">
<meta property="og:type" content="article">
<meta property="og:title" content="Kafka之旅（三）Consumer-Poll模型">
<meta property="og:url" content="http://example.com/2021/06/13/Kafka%E4%B9%8B%E6%97%85%EF%BC%88%E4%B8%89%EF%BC%89Consumer-Poll%E6%A8%A1%E5%9E%8B/index.html">
<meta property="og:site_name" content="矩阵编程">
<meta property="og:description" content="&emsp;&emsp;KafkaConsumer#poll是我们消费消息的核心逻辑所在，从某种意义上来说理解了Kafka的poll模型才能真正用好Kafka Consumer，poll代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public Con">
<meta property="og:locale">
<meta property="article:published_time" content="2021-06-13T14:11:05.000Z">
<meta property="article:modified_time" content="2021-06-13T14:11:05.676Z">
<meta property="article:author" content="functm">
<meta property="article:tag" content="Kafka">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2021/06/13/Kafka%E4%B9%8B%E6%97%85%EF%BC%88%E4%B8%89%EF%BC%89Consumer-Poll%E6%A8%A1%E5%9E%8B/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-Hans","comments":true,"permalink":"http://example.com/2021/06/13/Kafka%E4%B9%8B%E6%97%85%EF%BC%88%E4%B8%89%EF%BC%89Consumer-Poll%E6%A8%A1%E5%9E%8B/","path":"2021/06/13/Kafka之旅（三）Consumer-Poll模型/","title":"Kafka之旅（三）Consumer-Poll模型"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Kafka之旅（三）Consumer-Poll模型 | 矩阵编程</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">矩阵编程</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">functm</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/13/Kafka%E4%B9%8B%E6%97%85%EF%BC%88%E4%B8%89%EF%BC%89Consumer-Poll%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="functm">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="矩阵编程">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Kafka之旅（三）Consumer-Poll模型 | 矩阵编程">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Kafka之旅（三）Consumer-Poll模型
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-13 22:11:05" itemprop="dateCreated datePublished" datetime="2021-06-13T22:11:05+08:00">2021-06-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Kafka/" itemprop="url" rel="index"><span itemprop="name">Kafka</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>&emsp;&emsp;<strong>KafkaConsumer#poll</strong>是我们消费消息的核心逻辑所在，从某种意义上来说理解了Kafka的poll模型才能真正用好Kafka Consumer，poll代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ConsumerRecords&lt;K, V&gt; <span class="title function_">poll</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> timeoutMs)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> poll(time.timer(timeoutMs), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> ConsumerRecords&lt;K, V&gt; <span class="title function_">poll</span><span class="params">(<span class="keyword">final</span> Duration timeout)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> poll(time.timer(timeout), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> ConsumerRecords&lt;K, V&gt; <span class="title function_">poll</span><span class="params">(<span class="keyword">final</span> Timer timer, <span class="keyword">final</span> <span class="type">boolean</span> includeMetadataInTimeout)</span> &#123;</span><br><span class="line">    acquireAndEnsureOpen();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.kafkaConsumerMetrics.recordPollStart(timer.currentTimeMs());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.subscriptions.hasNoSubscriptionOrUserAssignment()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Consumer is not subscribed to any topics or assigned any partitions&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            client.maybeTriggerWakeup();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (includeMetadataInTimeout) &#123;</span><br><span class="line">                <span class="comment">// try to update assignment metadata BUT do not need to block on the timer for join group</span></span><br><span class="line">                updateAssignmentMetadataIfNeeded(timer, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!updateAssignmentMetadataIfNeeded(time.timer(Long.MAX_VALUE), <span class="literal">true</span>)) &#123;</span><br><span class="line">                    log.warn(<span class="string">&quot;Still waiting for metadata&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records = pollForFetches(timer);</span><br><span class="line">            <span class="keyword">if</span> (!records.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// before returning the fetched records, we can send off the next round of fetches</span></span><br><span class="line">                <span class="comment">// and avoid block waiting for their responses to enable pipelining while the user</span></span><br><span class="line">                <span class="comment">// is handling the fetched records.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// <span class="doctag">NOTE:</span> since the consumed position has already been updated, we must not allow</span></span><br><span class="line">                <span class="comment">// wakeups or any other errors to be triggered prior to returning the fetched records.</span></span><br><span class="line">                <span class="keyword">if</span> (fetcher.sendFetches() &gt; <span class="number">0</span> || client.hasPendingRequests()) &#123;</span><br><span class="line">                    client.transmitSends();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.interceptors.onConsume(<span class="keyword">new</span> <span class="title class_">ConsumerRecords</span>&lt;&gt;(records));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (timer.notExpired());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ConsumerRecords.empty();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        release();</span><br><span class="line">        <span class="built_in">this</span>.kafkaConsumerMetrics.recordPollEnd(timer.currentTimeMs());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<ol>
<li>poll主要有两种方式，看上去两个方法神似，一样的timeout参数命名，而且其实底层调用的方法都一样，唯一的区别是<strong>includeMetadataInTimeout</strong>参数。<strong>includeMetadataInTimeout&#x3D;True</strong>表示获取消息的超时时间是否包含了获取元数据的时间，使用的时候需要注意。</li>
<li>整个poll流程大致分两步走：<strong>updateAssignmentMetadataIfNeeded</strong>更新分区的元数据信息和<strong>pollForFetches</strong>拉取数据。</li>
</ol>
<p>简单看一下<strong>KafkaConsumer#updateAssignmentMetadataIfNeeded</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">updateAssignmentMetadataIfNeeded</span><span class="params">(<span class="keyword">final</span> Timer timer, <span class="keyword">final</span> <span class="type">boolean</span> waitForJoinGroup)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (coordinator != <span class="literal">null</span> &amp;&amp; !coordinator.poll(timer, waitForJoinGroup)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> updateFetchPositions(timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<strong>ConsumerCoordinator#poll</strong>，<strong>ConsumerCoordinator</strong>和服务端<strong>GroupCoordinator</strong>紧密结合，负责 consumer group 成员变更、rebalance以及offset管理等。<strong>ConsumerCoordinator</strong>这一部分的代码留待后面再说，下面着重看一下poll的主流程，<strong>KafkaConsumer#pollForFetches</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; <span class="title function_">pollForFetches</span><span class="params">(Timer timer)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">pollTimeout</span> <span class="operator">=</span> coordinator == <span class="literal">null</span> ? timer.remainingMs() :</span><br><span class="line">            Math.min(coordinator.timeToNextPoll(timer.currentTimeMs()), timer.remainingMs());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if data is available already, return it immediately</span></span><br><span class="line">    <span class="keyword">final</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records = fetcher.fetchedRecords();</span><br><span class="line">    <span class="keyword">if</span> (!records.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> records;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send any new fetches (won&#x27;t resend pending fetches)</span></span><br><span class="line">    fetcher.sendFetches();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We do not want to be stuck blocking in poll if we are missing some positions</span></span><br><span class="line">    <span class="comment">// since the offset lookup may be backing off after a failure</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> the use of cachedSubscriptionHashAllFetchPositions means we MUST call</span></span><br><span class="line">    <span class="comment">// updateAssignmentMetadataIfNeeded before this method.</span></span><br><span class="line">    <span class="keyword">if</span> (!cachedSubscriptionHashAllFetchPositions &amp;&amp; pollTimeout &gt; retryBackoffMs) &#123;</span><br><span class="line">        pollTimeout = retryBackoffMs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Timer</span> <span class="variable">pollTimer</span> <span class="operator">=</span> time.timer(pollTimeout);</span><br><span class="line">    client.poll(pollTimer, () -&gt; &#123;</span><br><span class="line">        <span class="comment">// since a fetch might be completed by the background thread, we need this poll condition</span></span><br><span class="line">        <span class="comment">// to ensure that we do not block unnecessarily in poll()</span></span><br><span class="line">        <span class="keyword">return</span> !fetcher.hasAvailableFetches();</span><br><span class="line">    &#125;);</span><br><span class="line">    timer.update(pollTimer.currentTimeMs());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fetcher.fetchedRecords();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>Fetcher#fetchedRecords</strong> 如果已经获取到数据，马上返回；否则调用<strong>Fetcher#sendFetches</strong>发送获取数据的请求。</li>
<li><strong>ConsumerNetworkClient#poll</strong> 发送请求获取数据，如果有请求已经返回了，这里就不会阻塞；否则会进行阻塞（根据超时时间而定）。</li>
<li>最后再执行一遍<strong>Fetcher#fetchedRecords</strong>获取数据。</li>
</ol>
<p>从上面的代码分析，KafkaConsumer poll的重点在于<strong>Fetcher</strong>以及<strong>ConsumerNetworkClient</strong>，下面分布看一下这两个类做了什么。先看一下<strong>Fetcher#sendFetches</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">sendFetches</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Update metrics in case there was an assignment change</span></span><br><span class="line">        sensors.maybeUpdateAssignment(subscriptions);</span><br><span class="line"></span><br><span class="line">        Map&lt;Node, FetchSessionHandler.FetchRequestData&gt; fetchRequestMap = prepareFetchRequests();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Node, FetchSessionHandler.FetchRequestData&gt; entry : fetchRequestMap.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">fetchTarget</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="keyword">final</span> FetchSessionHandler.<span class="type">FetchRequestData</span> <span class="variable">data</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            <span class="keyword">final</span> FetchRequest.<span class="type">Builder</span> <span class="variable">request</span> <span class="operator">=</span> FetchRequest.Builder</span><br><span class="line">                    .forConsumer(<span class="built_in">this</span>.maxWaitMs, <span class="built_in">this</span>.minBytes, data.toSend())</span><br><span class="line">                    .isolationLevel(isolationLevel)</span><br><span class="line">                    .setMaxBytes(<span class="built_in">this</span>.maxBytes)</span><br><span class="line">                    .metadata(data.metadata())</span><br><span class="line">                    .toForget(data.toForget())</span><br><span class="line">                    .rackId(clientRackId);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;Sending &#123;&#125; &#123;&#125; to broker &#123;&#125;&quot;</span>, isolationLevel, data.toString(), fetchTarget);</span><br><span class="line">            &#125;</span><br><span class="line">            RequestFuture&lt;ClientResponse&gt; future = client.send(fetchTarget, request);</span><br><span class="line">            <span class="comment">// We add the node to the set of nodes with pending fetch requests before adding the</span></span><br><span class="line">            <span class="comment">// listener because the future may have been fulfilled on another thread (e.g. during a</span></span><br><span class="line">            <span class="comment">// disconnection being handled by the heartbeat thread) which will mean the listener</span></span><br><span class="line">            <span class="comment">// will be invoked synchronously.</span></span><br><span class="line">            <span class="built_in">this</span>.nodesWithPendingFetchRequests.add(entry.getKey().id());</span><br><span class="line">            future.addListener(<span class="keyword">new</span> <span class="title class_">RequestFutureListener</span>&lt;ClientResponse&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(ClientResponse resp)</span> &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (Fetcher.<span class="built_in">this</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                            FetchResponse&lt;Records&gt; response = (FetchResponse&lt;Records&gt;) resp.responseBody();</span><br><span class="line">                            <span class="type">FetchSessionHandler</span> <span class="variable">handler</span> <span class="operator">=</span> sessionHandler(fetchTarget.id());</span><br><span class="line">                            <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">                                log.error(<span class="string">&quot;Unable to find FetchSessionHandler for node &#123;&#125;. Ignoring fetch response.&quot;</span>,</span><br><span class="line">                                        fetchTarget.id());</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (!handler.handleResponse(response)) &#123;</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            Set&lt;TopicPartition&gt; partitions = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(response.responseData().keySet());</span><br><span class="line">                            <span class="type">FetchResponseMetricAggregator</span> <span class="variable">metricAggregator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FetchResponseMetricAggregator</span>(sensors, partitions);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">for</span> (Map.Entry&lt;TopicPartition, FetchResponse.PartitionData&lt;Records&gt;&gt; entry : response.responseData().entrySet()) &#123;</span><br><span class="line">                                <span class="type">TopicPartition</span> <span class="variable">partition</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">                                FetchRequest.<span class="type">PartitionData</span> <span class="variable">requestData</span> <span class="operator">=</span> data.sessionPartitions().get(partition);</span><br><span class="line">                                <span class="keyword">if</span> (requestData == <span class="literal">null</span>) &#123;</span><br><span class="line">                                    String message;</span><br><span class="line">                                    <span class="keyword">if</span> (data.metadata().isFull()) &#123;</span><br><span class="line">                                        message = MessageFormatter.arrayFormat(</span><br><span class="line">                                                <span class="string">&quot;Response for missing full request partition: partition=&#123;&#125;; metadata=&#123;&#125;&quot;</span>,</span><br><span class="line">                                                <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;partition, data.metadata()&#125;).getMessage();</span><br><span class="line">                                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        message = MessageFormatter.arrayFormat(</span><br><span class="line">                                                <span class="string">&quot;Response for missing session request partition: partition=&#123;&#125;; metadata=&#123;&#125;; toSend=&#123;&#125;; toForget=&#123;&#125;&quot;</span>,</span><br><span class="line">                                                <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;partition, data.metadata(), data.toSend(), data.toForget()&#125;).getMessage();</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// Received fetch response for missing session partition</span></span><br><span class="line">                                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(message);</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="type">long</span> <span class="variable">fetchOffset</span> <span class="operator">=</span> requestData.fetchOffset;</span><br><span class="line">                                    FetchResponse.PartitionData&lt;Records&gt; partitionData = entry.getValue();</span><br><span class="line"></span><br><span class="line">                                    log.debug(<span class="string">&quot;Fetch &#123;&#125; at offset &#123;&#125; for partition &#123;&#125; returned fetch data &#123;&#125;&quot;</span>,</span><br><span class="line">                                            isolationLevel, fetchOffset, partition, partitionData);</span><br><span class="line"></span><br><span class="line">                                    Iterator&lt;? <span class="keyword">extends</span> <span class="title class_">RecordBatch</span>&gt; batches = partitionData.records.batches().iterator();</span><br><span class="line">                                    <span class="type">short</span> <span class="variable">responseVersion</span> <span class="operator">=</span> resp.requestHeader().apiVersion();</span><br><span class="line"></span><br><span class="line">                                    completedFetches.add(<span class="keyword">new</span> <span class="title class_">CompletedFetch</span>(partition, partitionData,</span><br><span class="line">                                            metricAggregator, batches, fetchOffset, responseVersion));</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            sensors.fetchLatency.record(resp.requestLatencyMs());</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            nodesWithPendingFetchRequests.remove(fetchTarget.id());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(RuntimeException e)</span> &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (Fetcher.<span class="built_in">this</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="type">FetchSessionHandler</span> <span class="variable">handler</span> <span class="operator">=</span> sessionHandler(fetchTarget.id());</span><br><span class="line">                            <span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">                                handler.handleError(e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            nodesWithPendingFetchRequests.remove(fetchTarget.id());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fetchRequestMap.size();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>先看一下<strong>Fetcher#fetchedRecords</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; <span class="title function_">fetchedRecords</span><span class="params">()</span> &#123;</span><br><span class="line">     Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; fetched = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">     Queue&lt;CompletedFetch&gt; pausedCompletedFetches = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">     <span class="type">int</span> <span class="variable">recordsRemaining</span> <span class="operator">=</span> maxPollRecords;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">while</span> (recordsRemaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (nextInLineFetch == <span class="literal">null</span> || nextInLineFetch.isConsumed) &#123;</span><br><span class="line">                 <span class="type">CompletedFetch</span> <span class="variable">records</span> <span class="operator">=</span> completedFetches.peek();</span><br><span class="line">                 <span class="keyword">if</span> (records == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">if</span> (records.notInitialized()) &#123;</span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                         nextInLineFetch = initializeCompletedFetch(records);</span><br><span class="line">                     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                         <span class="comment">// Remove a completedFetch upon a parse with exception if (1) it contains no records, and</span></span><br><span class="line">                         <span class="comment">// (2) there are no fetched records with actual content preceding this exception.</span></span><br><span class="line">                         <span class="comment">// The first condition ensures that the completedFetches is not stuck with the same completedFetch</span></span><br><span class="line">                         <span class="comment">// in cases such as the TopicAuthorizationException, and the second condition ensures that no</span></span><br><span class="line">                         <span class="comment">// potential data loss due to an exception in a following record.</span></span><br><span class="line">                         FetchResponse.<span class="type">PartitionData</span> <span class="variable">partition</span> <span class="operator">=</span> records.partitionData;</span><br><span class="line">                         <span class="keyword">if</span> (fetched.isEmpty() &amp;&amp; (partition.records == <span class="literal">null</span> || partition.records.sizeInBytes() == <span class="number">0</span>)) &#123;</span><br><span class="line">                             completedFetches.poll();</span><br><span class="line">                         &#125;</span><br><span class="line">                         <span class="keyword">throw</span> e;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     nextInLineFetch = records;</span><br><span class="line">                 &#125;</span><br><span class="line">                 completedFetches.poll();</span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subscriptions.isPaused(nextInLineFetch.partition)) &#123;</span><br><span class="line">                 <span class="comment">// when the partition is paused we add the records back to the completedFetches queue instead of draining</span></span><br><span class="line">                 <span class="comment">// them so that they can be returned on a subsequent poll if the partition is resumed at that time</span></span><br><span class="line">                 log.debug(<span class="string">&quot;Skipping fetching records for assigned partition &#123;&#125; because it is paused&quot;</span>, nextInLineFetch.partition);</span><br><span class="line">                 pausedCompletedFetches.add(nextInLineFetch);</span><br><span class="line">                 nextInLineFetch = <span class="literal">null</span>;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 List&lt;ConsumerRecord&lt;K, V&gt;&gt; records = fetchRecords(nextInLineFetch, recordsRemaining);</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">if</span> (!records.isEmpty()) &#123;</span><br><span class="line">                     <span class="type">TopicPartition</span> <span class="variable">partition</span> <span class="operator">=</span> nextInLineFetch.partition;</span><br><span class="line">                     List&lt;ConsumerRecord&lt;K, V&gt;&gt; currentRecords = fetched.get(partition);</span><br><span class="line">                     <span class="keyword">if</span> (currentRecords == <span class="literal">null</span>) &#123;</span><br><span class="line">                         fetched.put(partition, records);</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                         <span class="comment">// this case shouldn&#x27;t usually happen because we only send one fetch at a time per partition,</span></span><br><span class="line">                         <span class="comment">// but it might conceivably happen in some rare cases (such as partition leader changes).</span></span><br><span class="line">                         <span class="comment">// we have to copy to a new list because the old one may be immutable</span></span><br><span class="line">                         List&lt;ConsumerRecord&lt;K, V&gt;&gt; newRecords = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(records.size() + currentRecords.size());</span><br><span class="line">                         newRecords.addAll(currentRecords);</span><br><span class="line">                         newRecords.addAll(records);</span><br><span class="line">                         fetched.put(partition, newRecords);</span><br><span class="line">                     &#125;</span><br><span class="line">                     recordsRemaining -= records.size();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (KafkaException e) &#123;</span><br><span class="line">         <span class="keyword">if</span> (fetched.isEmpty())</span><br><span class="line">             <span class="keyword">throw</span> e;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// add any polled completed fetches for paused partitions back to the completed fetches queue to be</span></span><br><span class="line">         <span class="comment">// re-evaluated in the next poll</span></span><br><span class="line">         completedFetches.addAll(pausedCompletedFetches);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> fetched;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>此方法处在一个循环内，直到获取的数量达到设定的<strong>max.poll.records</strong>（poll操作返回的最大记录数）</li>
<li>nextInLineFetch（CompletedFetch）实例为空或者其属性isConsumed&#x3D;true，则尝试从completedFetches（ConcurrentLinkedQueue<CompletedFetch>）队列中获取一个CompletedFetch并尝试初始化。<strong>CompletedFetch</strong>是已完成请求的封装，包含本次请求的分区以及获取到的一些数据记录等。</li>
<li>判断订阅分区状态，如果isPaused则将该CompletedFetch先挂起（处理完成最后会重新丢入completedFetches）。</li>
<li>处理CompletedFetch的地方重点还要看**Fetcher#fetchRecords(CompletedFetch completedFetch, int maxRecords)**： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;ConsumerRecord&lt;K, V&gt;&gt; <span class="title function_">fetchRecords</span><span class="params">(CompletedFetch completedFetch, <span class="type">int</span> maxRecords)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!subscriptions.isAssigned(completedFetch.partition)) &#123;</span><br><span class="line">        <span class="comment">// this can happen when a rebalance happened before fetched records are returned to the consumer&#x27;s poll call</span></span><br><span class="line">        log.debug(<span class="string">&quot;Not returning fetched records for partition &#123;&#125; since it is no longer assigned&quot;</span>,</span><br><span class="line">                completedFetch.partition);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!subscriptions.isFetchable(completedFetch.partition)) &#123;</span><br><span class="line">        <span class="comment">// this can happen when a partition is paused before fetched records are returned to the consumer&#x27;s</span></span><br><span class="line">        <span class="comment">// poll call or if the offset is being reset</span></span><br><span class="line">        log.debug(<span class="string">&quot;Not returning fetched records for assigned partition &#123;&#125; since it is no longer fetchable&quot;</span>,</span><br><span class="line">                completedFetch.partition);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">FetchPosition</span> <span class="variable">position</span> <span class="operator">=</span> subscriptions.position(completedFetch.partition);</span><br><span class="line">        <span class="keyword">if</span> (position == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Missing position for fetchable partition &quot;</span> + completedFetch.partition);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (completedFetch.nextFetchOffset == position.offset) &#123;</span><br><span class="line">            List&lt;ConsumerRecord&lt;K, V&gt;&gt; partRecords = completedFetch.fetchRecords(maxRecords);</span><br><span class="line"></span><br><span class="line">            log.trace(<span class="string">&quot;Returning &#123;&#125; fetched records at offset &#123;&#125; for assigned partition &#123;&#125;&quot;</span>,</span><br><span class="line">                    partRecords.size(), position, completedFetch.partition);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (completedFetch.nextFetchOffset &gt; position.offset) &#123;</span><br><span class="line">                <span class="type">FetchPosition</span> <span class="variable">nextPosition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FetchPosition</span>(</span><br><span class="line">                        completedFetch.nextFetchOffset,</span><br><span class="line">                        completedFetch.lastEpoch,</span><br><span class="line">                        position.currentLeader);</span><br><span class="line">                log.trace(<span class="string">&quot;Update fetching position to &#123;&#125; for partition &#123;&#125;&quot;</span>, nextPosition, completedFetch.partition);</span><br><span class="line">                subscriptions.position(completedFetch.partition, nextPosition);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">Long</span> <span class="variable">partitionLag</span> <span class="operator">=</span> subscriptions.partitionLag(completedFetch.partition, isolationLevel);</span><br><span class="line">            <span class="keyword">if</span> (partitionLag != <span class="literal">null</span>)</span><br><span class="line">                <span class="built_in">this</span>.sensors.recordPartitionLag(completedFetch.partition, partitionLag);</span><br><span class="line"></span><br><span class="line">            <span class="type">Long</span> <span class="variable">lead</span> <span class="operator">=</span> subscriptions.partitionLead(completedFetch.partition);</span><br><span class="line">            <span class="keyword">if</span> (lead != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.sensors.recordPartitionLead(completedFetch.partition, lead);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> partRecords;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// these records aren&#x27;t next in line based on the last consumed position, ignore them</span></span><br><span class="line">            <span class="comment">// they must be from an obsolete request</span></span><br><span class="line">            log.debug(<span class="string">&quot;Ignoring fetched records for &#123;&#125; at offset &#123;&#125; since the current position is &#123;&#125;&quot;</span>,</span><br><span class="line">                    completedFetch.partition, completedFetch.nextFetchOffset, position);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.trace(<span class="string">&quot;Draining fetched records for partition &#123;&#125;&quot;</span>, completedFetch.partition);</span><br><span class="line">    completedFetch.drain();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> emptyList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>SubscriptionState#position</strong>获取到当前的消费进度（参照PartitionStates，实际存储在其内部的一个LinkedHashMap中），调用<strong>CompletedFetch#fetchRecords</strong>获取数据并更新PartitionStates的进度，最后调用<strong>CompletedFetch#drain</strong>完成该批次消费。</li>
<li><strong>SubscriptionState#position</strong>设置当前进度，这里关系后续commit的提交。</li>
</ul>
</li>
</ol>
<p>其中<strong>CompletedFetch#fetchRecords</strong>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;ConsumerRecord&lt;K, V&gt;&gt; <span class="title function_">fetchRecords</span><span class="params">(<span class="type">int</span> maxRecords)</span> &#123;</span><br><span class="line">    <span class="comment">// Error when fetching the next record before deserialization.</span></span><br><span class="line">    <span class="keyword">if</span> (corruptLastRecord)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">KafkaException</span>(<span class="string">&quot;Received exception when fetching the next record from &quot;</span> + partition</span><br><span class="line">                                     + <span class="string">&quot;. If needed, please seek past the record to &quot;</span></span><br><span class="line">                                     + <span class="string">&quot;continue consumption.&quot;</span>, cachedRecordException);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isConsumed)</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line"></span><br><span class="line">    List&lt;ConsumerRecord&lt;K, V&gt;&gt; records = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxRecords; i++) &#123;</span><br><span class="line">            <span class="comment">// Only move to next record if there was no exception in the last fetch. Otherwise we should</span></span><br><span class="line">            <span class="comment">// use the last record to do deserialization again.</span></span><br><span class="line">            <span class="keyword">if</span> (cachedRecordException == <span class="literal">null</span>) &#123;</span><br><span class="line">                corruptLastRecord = <span class="literal">true</span>;</span><br><span class="line">                lastRecord = nextFetchedRecord();</span><br><span class="line">                corruptLastRecord = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (lastRecord == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            records.add(parseRecord(partition, currentBatch, lastRecord));</span><br><span class="line">            recordsRead++;</span><br><span class="line">            bytesRead += lastRecord.sizeInBytes();</span><br><span class="line">            nextFetchOffset = lastRecord.offset() + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// In some cases, the deserialization may have thrown an exception and the retry may succeed,</span></span><br><span class="line">            <span class="comment">// we allow user to move forward in this case.</span></span><br><span class="line">            cachedRecordException = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SerializationException se) &#123;</span><br><span class="line">        cachedRecordException = se;</span><br><span class="line">        <span class="keyword">if</span> (records.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> se;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (KafkaException e) &#123;</span><br><span class="line">        cachedRecordException = e;</span><br><span class="line">        <span class="keyword">if</span> (records.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">KafkaException</span>(<span class="string">&quot;Received exception when fetching the next record from &quot;</span> + partition</span><br><span class="line">                                         + <span class="string">&quot;. If needed, please seek past the record to &quot;</span></span><br><span class="line">                                         + <span class="string">&quot;continue consumption.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> records;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>nextFetchedRecord</strong>从CloseableIterator<Record>中获取最新的record，<strong>parseRecord</strong>将该record转化为ConsumerRecord。至此整个<strong>Fetcher#fetchedRecords()<strong>完成获取数据流程，但是初始</strong>Fetcher#fetchedRecords()<strong>获取到数据肯定是空的，接下来回过头重新从</strong>KafkaConsumer#pollForFetches</strong>开始，看一下<strong>Fetcher#sendFetches</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">sendFetches</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Update metrics in case there was an assignment change</span></span><br><span class="line">    sensors.maybeUpdateAssignment(subscriptions);</span><br><span class="line"></span><br><span class="line">    Map&lt;Node, FetchSessionHandler.FetchRequestData&gt; fetchRequestMap = prepareFetchRequests();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Node, FetchSessionHandler.FetchRequestData&gt; entry : fetchRequestMap.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">fetchTarget</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="keyword">final</span> FetchSessionHandler.<span class="type">FetchRequestData</span> <span class="variable">data</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">        <span class="keyword">final</span> FetchRequest.<span class="type">Builder</span> <span class="variable">request</span> <span class="operator">=</span> FetchRequest.Builder</span><br><span class="line">                .forConsumer(<span class="built_in">this</span>.maxWaitMs, <span class="built_in">this</span>.minBytes, data.toSend())</span><br><span class="line">                .isolationLevel(isolationLevel)</span><br><span class="line">                .setMaxBytes(<span class="built_in">this</span>.maxBytes)</span><br><span class="line">                .metadata(data.metadata())</span><br><span class="line">                .toForget(data.toForget())</span><br><span class="line">                .rackId(clientRackId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;Sending &#123;&#125; &#123;&#125; to broker &#123;&#125;&quot;</span>, isolationLevel, data.toString(), fetchTarget);</span><br><span class="line">        &#125;</span><br><span class="line">        RequestFuture&lt;ClientResponse&gt; future = client.send(fetchTarget, request);</span><br><span class="line">        <span class="comment">// We add the node to the set of nodes with pending fetch requests before adding the</span></span><br><span class="line">        <span class="comment">// listener because the future may have been fulfilled on another thread (e.g. during a</span></span><br><span class="line">        <span class="comment">// disconnection being handled by the heartbeat thread) which will mean the listener</span></span><br><span class="line">        <span class="comment">// will be invoked synchronously.</span></span><br><span class="line">        <span class="built_in">this</span>.nodesWithPendingFetchRequests.add(entry.getKey().id());</span><br><span class="line">        future.addListener(<span class="keyword">new</span> <span class="title class_">RequestFutureListener</span>&lt;ClientResponse&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(ClientResponse resp)</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Fetcher.<span class="built_in">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                        FetchResponse&lt;Records&gt; response = (FetchResponse&lt;Records&gt;) resp.responseBody();</span><br><span class="line">                        <span class="type">FetchSessionHandler</span> <span class="variable">handler</span> <span class="operator">=</span> sessionHandler(fetchTarget.id());</span><br><span class="line">                        <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">                            log.error(<span class="string">&quot;Unable to find FetchSessionHandler for node &#123;&#125;. Ignoring fetch response.&quot;</span>,</span><br><span class="line">                                    fetchTarget.id());</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (!handler.handleResponse(response)) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        Set&lt;TopicPartition&gt; partitions = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(response.responseData().keySet());</span><br><span class="line">                        <span class="type">FetchResponseMetricAggregator</span> <span class="variable">metricAggregator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FetchResponseMetricAggregator</span>(sensors, partitions);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (Map.Entry&lt;TopicPartition, FetchResponse.PartitionData&lt;Records&gt;&gt; entry : response.responseData().entrySet()) &#123;</span><br><span class="line">                            <span class="type">TopicPartition</span> <span class="variable">partition</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">                            FetchRequest.<span class="type">PartitionData</span> <span class="variable">requestData</span> <span class="operator">=</span> data.sessionPartitions().get(partition);</span><br><span class="line">                            <span class="keyword">if</span> (requestData == <span class="literal">null</span>) &#123;</span><br><span class="line">                                String message;</span><br><span class="line">                                <span class="keyword">if</span> (data.metadata().isFull()) &#123;</span><br><span class="line">                                    message = MessageFormatter.arrayFormat(</span><br><span class="line">                                            <span class="string">&quot;Response for missing full request partition: partition=&#123;&#125;; metadata=&#123;&#125;&quot;</span>,</span><br><span class="line">                                            <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;partition, data.metadata()&#125;).getMessage();</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    message = MessageFormatter.arrayFormat(</span><br><span class="line">                                            <span class="string">&quot;Response for missing session request partition: partition=&#123;&#125;; metadata=&#123;&#125;; toSend=&#123;&#125;; toForget=&#123;&#125;&quot;</span>,</span><br><span class="line">                                            <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;partition, data.metadata(), data.toSend(), data.toForget()&#125;).getMessage();</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// Received fetch response for missing session partition</span></span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(message);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="type">long</span> <span class="variable">fetchOffset</span> <span class="operator">=</span> requestData.fetchOffset;</span><br><span class="line">                                FetchResponse.PartitionData&lt;Records&gt; partitionData = entry.getValue();</span><br><span class="line"></span><br><span class="line">                                log.debug(<span class="string">&quot;Fetch &#123;&#125; at offset &#123;&#125; for partition &#123;&#125; returned fetch data &#123;&#125;&quot;</span>,</span><br><span class="line">                                        isolationLevel, fetchOffset, partition, partitionData);</span><br><span class="line"></span><br><span class="line">                                Iterator&lt;? <span class="keyword">extends</span> <span class="title class_">RecordBatch</span>&gt; batches = partitionData.records.batches().iterator();</span><br><span class="line">                                <span class="type">short</span> <span class="variable">responseVersion</span> <span class="operator">=</span> resp.requestHeader().apiVersion();</span><br><span class="line"></span><br><span class="line">                                completedFetches.add(<span class="keyword">new</span> <span class="title class_">CompletedFetch</span>(partition, partitionData,</span><br><span class="line">                                        metricAggregator, batches, fetchOffset, responseVersion));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        sensors.fetchLatency.record(resp.requestLatencyMs());</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        nodesWithPendingFetchRequests.remove(fetchTarget.id());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(RuntimeException e)</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Fetcher.<span class="built_in">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">FetchSessionHandler</span> <span class="variable">handler</span> <span class="operator">=</span> sessionHandler(fetchTarget.id());</span><br><span class="line">                        <span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">                            handler.handleError(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        nodesWithPendingFetchRequests.remove(fetchTarget.id());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fetchRequestMap.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>prepareFetchRequests()<strong>对每个节点构建请求，主要是通过</strong>ConsumerNetworkClient#send</strong>发送网络请求，然后通过<strong>RequestFutureListener</strong>作为异步回调处理请求结果。</li>
<li>先说一下<strong>RequestFutureListener</strong>处理结果的地方，主要处理返回的<strong>ClientResponse</strong>，提取数据封装成<strong>CompletedFetch</strong>并放入completedFetches（ConcurrentLinkedQueue<CompletedFetch>）中，等待下一次poll的时候直接从completedFetches获取数据，这个流程和上面是一致的。</li>
</ol>
<p>下面主要是看一下<strong>ConsumerNetworkClient#send</strong>是如何发送网络请求的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> RequestFuture&lt;ClientResponse&gt; <span class="title function_">send</span><span class="params">(Node node, AbstractRequest.Builder&lt;?&gt; requestBuilder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> send(node, requestBuilder, requestTimeoutMs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> RequestFuture&lt;ClientResponse&gt; <span class="title function_">send</span><span class="params">(Node node,</span></span><br><span class="line"><span class="params">                                            AbstractRequest.Builder&lt;?&gt; requestBuilder,</span></span><br><span class="line"><span class="params">                                            <span class="type">int</span> requestTimeoutMs)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> time.milliseconds();</span><br><span class="line">    <span class="type">RequestFutureCompletionHandler</span> <span class="variable">completionHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestFutureCompletionHandler</span>();</span><br><span class="line">    <span class="type">ClientRequest</span> <span class="variable">clientRequest</span> <span class="operator">=</span> client.newClientRequest(node.idString(), requestBuilder, now, <span class="literal">true</span>,</span><br><span class="line">            requestTimeoutMs, completionHandler);</span><br><span class="line">    unsent.put(node, clientRequest);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wakeup the client in case it is blocking in poll so that we can send the queued request</span></span><br><span class="line">    client.wakeup();</span><br><span class="line">    <span class="keyword">return</span> completionHandler.future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这个代码觉得有点熟悉，整个流程有点像<a href="/2020/12/11/Kafka%E4%B9%8B%E6%97%85%EF%BC%88%E4%B8%80%EF%BC%89Producer/">Kafka之旅（一）Producer</a>KafkaClient的部分，这里也仅仅是封装了<strong>RequestFutureCompletionHandler</strong>作为返回结果处理，然后将整个<strong>ClientRequest</strong>请求放入unsent（<strong>UnsentRequests</strong>，其内部维护了一个ConcurrentMap&lt;Node, ConcurrentLinkedQueue<ClientRequest>&gt;节点队列），最后调用<strong>Selectable#wakeup</strong>唤醒阻塞状态的selector。那么发送网络请求的真实调用在哪里？沿着这个unsent去找最终的出口，最后发现其实是在<strong>ConsumerNetworkClient#poll</strong>这个地方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">poll</span><span class="params">(Timer timer, PollCondition pollCondition, <span class="type">boolean</span> disableWakeup)</span> &#123;</span><br><span class="line">        <span class="comment">// there may be handlers which need to be invoked if we woke up the previous call to poll</span></span><br><span class="line">        firePendingCompletedRequests();</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Handle async disconnects prior to attempting any sends</span></span><br><span class="line">            handlePendingDisconnects();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// send all the requests we can send now</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">pollDelayMs</span> <span class="operator">=</span> trySend(timer.currentTimeMs());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// check whether the poll is still needed by the caller. Note that if the expected completion</span></span><br><span class="line">            <span class="comment">// condition becomes satisfied after the call to shouldBlock() (because of a fired completion</span></span><br><span class="line">            <span class="comment">// handler), the client will be woken up.</span></span><br><span class="line">            <span class="keyword">if</span> (pendingCompletion.isEmpty() &amp;&amp; (pollCondition == <span class="literal">null</span> || pollCondition.shouldBlock())) &#123;</span><br><span class="line">                <span class="comment">// if there are no requests in flight, do not block longer than the retry backoff</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">pollTimeout</span> <span class="operator">=</span> Math.min(timer.remainingMs(), pollDelayMs);</span><br><span class="line">                <span class="keyword">if</span> (client.inFlightRequestCount() == <span class="number">0</span>)</span><br><span class="line">                    pollTimeout = Math.min(pollTimeout, retryBackoffMs);</span><br><span class="line">                client.poll(pollTimeout, timer.currentTimeMs());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                client.poll(<span class="number">0</span>, timer.currentTimeMs());</span><br><span class="line">            &#125;</span><br><span class="line">            timer.update();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// handle any disconnects by failing the active requests. note that disconnects must</span></span><br><span class="line">            <span class="comment">// be checked immediately following poll since any subsequent call to client.ready()</span></span><br><span class="line">            <span class="comment">// will reset the disconnect status</span></span><br><span class="line">            checkDisconnects(timer.currentTimeMs());</span><br><span class="line">            <span class="keyword">if</span> (!disableWakeup) &#123;</span><br><span class="line">                <span class="comment">// trigger wakeups after checking for disconnects so that the callbacks will be ready</span></span><br><span class="line">                <span class="comment">// to be fired on the next call to poll()</span></span><br><span class="line">                maybeTriggerWakeup();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// throw InterruptException if this thread is interrupted</span></span><br><span class="line">            maybeThrowInterruptException();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// try again to send requests since buffer space may have been</span></span><br><span class="line">            <span class="comment">// cleared or a connect finished in the poll</span></span><br><span class="line">            trySend(timer.currentTimeMs());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// fail requests that couldn&#x27;t be sent if they have expired</span></span><br><span class="line">            failExpiredRequests(timer.currentTimeMs());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// clean unsent requests collection to keep the map from growing indefinitely</span></span><br><span class="line">            unsent.clean();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// called without the lock to avoid deadlock potential if handlers need to acquire locks</span></span><br><span class="line">        firePendingCompletedRequests();</span><br><span class="line"></span><br><span class="line">        metadata.maybeThrowAnyException();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>ConsumerNetworkClient#trySend</strong>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">trySend</span><span class="params">(<span class="type">long</span> now)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">pollDelayMs</span> <span class="operator">=</span> maxPollTimeoutMs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send any requests that can be sent now</span></span><br><span class="line">    <span class="keyword">for</span> (Node node : unsent.nodes()) &#123;</span><br><span class="line">        Iterator&lt;ClientRequest&gt; iterator = unsent.requestIterator(node);</span><br><span class="line">        <span class="keyword">if</span> (iterator.hasNext())</span><br><span class="line">            pollDelayMs = Math.min(pollDelayMs, client.pollDelayMs(node, now));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">ClientRequest</span> <span class="variable">request</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (client.ready(node, now)) &#123;</span><br><span class="line">                client.send(request, now);</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// try next node when current node is not ready</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pollDelayMs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历unsent中的请求，然后调用KafkaClient#send发送请求，最后调用KafkaClient#poll，又看到上文熟悉的KafkaClient调用方式，不再赘述。回到<strong>KafkaConsumer#pollForFetches</strong>，最后又是调用一遍<strong>Fetcher#fetchedRecords</strong>尝试再一次处理本次请求新拿到的数据，自此整个<strong>KafkaConsumer#poll</strong>流程处理完毕。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Kafka/" rel="tag"># Kafka</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/06/13/Kafka%E4%B9%8B%E6%97%85%EF%BC%88%E4%BA%8C%EF%BC%89Consumer%E8%AE%A2%E9%98%85/" rel="prev" title="Kafka之旅（二）Consumer订阅">
                  <i class="fa fa-angle-left"></i> Kafka之旅（二）Consumer订阅
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/06/13/%E8%B0%88CGLIB%E4%BB%A5%E5%8F%8A%E5%92%8CJDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%AF%B9%E6%AF%94/" rel="next" title="谈CGLIB以及和JDK动态代理的对比">
                  谈CGLIB以及和JDK动态代理的对比 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">functm</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
