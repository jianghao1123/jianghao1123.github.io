<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"jianghao1123.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="概览本文主要是记录产品性能优化以及迭代过程中遇到的各种问题，以及对问题的探究和反思。希望本文能带给大家一点启发，虽然这里有些问题或思考也并不一定单单与高并发（High Concurrency）有关，或者高并发的奥义也远不止于此。">
<meta property="og:type" content="article">
<meta property="og:title" content="高并发指引">
<meta property="og:url" content="https://jianghao1123.github.io/2025/06/16/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%8C%87%E5%BC%95/index.html">
<meta property="og:site_name" content="矩阵编程">
<meta property="og:description" content="概览本文主要是记录产品性能优化以及迭代过程中遇到的各种问题，以及对问题的探究和反思。希望本文能带给大家一点启发，虽然这里有些问题或思考也并不一定单单与高并发（High Concurrency）有关，或者高并发的奥义也远不止于此。">
<meta property="og:locale">
<meta property="article:published_time" content="2025-06-16T07:46:43.000Z">
<meta property="article:modified_time" content="2025-06-16T08:30:48.904Z">
<meta property="article:author" content="functm">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://jianghao1123.github.io/2025/06/16/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%8C%87%E5%BC%95/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-Hans","comments":true,"permalink":"https://jianghao1123.github.io/2025/06/16/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%8C%87%E5%BC%95/","path":"2025/06/16/高并发指引/","title":"高并发指引"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>高并发指引 | 矩阵编程</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">矩阵编程</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%A7%88"><span class="nav-number">1.</span> <span class="nav-text">概览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">2.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#cas"><span class="nav-number">2.0.1.</span> <span class="nav-text">cas</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="nav-number">2.0.2.</span> <span class="nav-text">乐观锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#volatile"><span class="nav-number">2.0.3.</span> <span class="nav-text">volatile</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A0%E5%BD%A2%E7%9A%84%E9%94%81"><span class="nav-number">2.0.4.</span> <span class="nav-text">无形的锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">2.0.5.</span> <span class="nav-text">分布式锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">2.0.6.</span> <span class="nav-text">死锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3"><span class="nav-number">3.</span> <span class="nav-text">Java语言相关</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#class"><span class="nav-number">3.0.1.</span> <span class="nav-text">class</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#string"><span class="nav-number">3.0.2.</span> <span class="nav-text">string</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#queue"><span class="nav-number">3.0.3.</span> <span class="nav-text">queue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#threadLocal"><span class="nav-number">3.0.4.</span> <span class="nav-text">threadLocal</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#gc"><span class="nav-number">3.0.5.</span> <span class="nav-text">gc</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#spring"><span class="nav-number">3.0.6.</span> <span class="nav-text">spring</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bean"><span class="nav-number">3.0.7.</span> <span class="nav-text">bean</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">3.0.8.</span> <span class="nav-text">序列化和反序列化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="nav-number">3.0.9.</span> <span class="nav-text">如何排查性能问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7"><span class="nav-number">4.</span> <span class="nav-text">熔断降级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kafka"><span class="nav-number">5.</span> <span class="nav-text">Kafka</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">6.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95"><span class="nav-number">6.0.1.</span> <span class="nav-text">索引</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE"><span class="nav-number">6.0.2.</span> <span class="nav-text">加载数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="nav-number">6.0.3.</span> <span class="nav-text">读写分离</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98"><span class="nav-number">7.</span> <span class="nav-text">缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Design-Pattern"><span class="nav-number">7.0.1.</span> <span class="nav-text">Design Pattern</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98"><span class="nav-number">7.0.2.</span> <span class="nav-text">本地缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98"><span class="nav-number">7.0.3.</span> <span class="nav-text">分布式缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%AE%9E%E8%B7%B5"><span class="nav-number">7.0.4.</span> <span class="nav-text">缓存实践</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">8.</span> <span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%91%E7%8E%87%E4%BC%B0%E8%AE%A1"><span class="nav-number">8.0.1.</span> <span class="nav-text">频率估计</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TopK"><span class="nav-number">8.0.2.</span> <span class="nav-text">TopK</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%95%B0%E4%BC%B0%E8%AE%A1"><span class="nav-number">8.0.3.</span> <span class="nav-text">基数估计</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E9%87%87%E6%A0%B7"><span class="nav-number">8.0.4.</span> <span class="nav-text">数据流采样</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Bloom-Filter"><span class="nav-number">8.0.5.</span> <span class="nav-text">Bloom Filter</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96-effective-%E5%BB%BA%E8%AE%AE"><span class="nav-number">9.</span> <span class="nav-text">其他 effective 建议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E5%B0%BE"><span class="nav-number">10.</span> <span class="nav-text">结尾</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">11.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">functm</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://jianghao1123.github.io/2025/06/16/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%8C%87%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="functm">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="矩阵编程">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="高并发指引 | 矩阵编程">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          高并发指引
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2025-06-16 15:46:43 / Modified: 16:30:48" itemprop="dateCreated datePublished" datetime="2025-06-16T15:46:43+08:00">2025-06-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>本文主要是记录产品性能优化以及迭代过程中遇到的各种问题，以及对问题的探究和反思。希望本文能带给大家一点启发，虽然这里有些问题或思考也并不一定单单与高并发（High Concurrency）有关，或者高并发的奥义也远不止于此。</p>
<span id="more"></span>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>在高并发编程中<strong>锁</strong>是不可绕开的一个机制，如果你使用了锁，那默认你对锁已经有了一些了解，在用锁之前，请务必遵循以下原则：</p>
<ol>
<li>尽量不用锁。</li>
<li>控制细粒度。</li>
<li>缩短时间。</li>
</ol>
<p>我见过太多在方法级别或整个块中加锁的代码，如果此段代码会频繁被执行，那么这个代码构建的产品也就基本告别了高并发设计。下面围绕这三个原则展开讲讲锁在使用过程中需要注意的点。</p>
<blockquote>
<p>代码就像一个极度脆弱的融合怪。</p>
</blockquote>
<p>无锁（Lock-Free）是高并发编程追求的目标，但是业务指向往往事与愿违，完美只存在于想象之中。不过我们依然有很多方式可以减少锁的使用，或者使用别的方式来提高加锁代码的性能，如下（供参考）：</p>
<h5 id="cas"><a href="#cas" class="headerlink" title="cas"></a>cas</h5><p><strong>cas机制</strong>在Java中常见实现工具类的有 <strong>ReentrantLock、StampedLock</strong>（比ReentrantReadWriteLock更快）<strong>、atomic（java.util.concurrent.atomic）</strong>。什么场景下使用 ReentrantLock，什么场景下使用 synchronized ？这是面试中经常会问的一个问题，想必对于一个实习长达三年半或者更久的的Java实习生肯定知道，但是你真的用过吗？比如有以下场景：</p>
<ol>
<li>多个线程处理数据，线程处理有时需要竞争一个锁，竞争到锁的线程会有一个长时间的IO操作，此时该如何加锁？</li>
<li>AtomicInteger或者AtomicLong也是计数器场景经常使用到的工具，但是对于频繁的更新操作（高度竞争），AtomicInteger或者AtomicLong真的快吗，还有没有比他们更快的？如果你不知道，推荐你再了解下<strong>LongAdder</strong>，这里简单说下 <strong>LongAdder</strong> 为什么快：因为在高度竞争的条件下，对一个值进行修改冲突的概率很高，需要不断 cas 导致时间浪费在循环上，如果将一个值拆分为多个值分散压力，那么性能就会显著提高。这种思想在高并发设计中也经常可以遇到，比如 ConcurrentHashMap 在JDK8以下的segment实现。</li>
</ol>
<h5 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h5><p>cas其实就是典型的<strong>乐观锁实现</strong>，单独拿出来主要是强调乐观锁的思想。乐观锁有一个假设的前提：<strong>一般情况下操作数据不会发生冲突</strong>。乐观锁常见于数据库更新操作，典型的SQL命令如：update table set field&#x3D;{new-value},version&#x3D;version+1 where id&#x3D;{id} and version&#x3D;{version}。</p>
<h5 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h5><p>并发编程有三大特性：<strong>原子性、可见性和有序性，volatile</strong>保证了可见性和一定的有序性。<strong>volatile</strong>这个关键字并不是Java独有的，在很多语言中如C、C++都有。检验你会不会使用 <strong>volatile</strong>这个关键字其实很简单，如：手写双检锁单例。在以下场景 <strong>volatile</strong>可以代替 synchronized（或者说要满足以下场景）：</p>
<ul>
<li>写入变量不依赖变量的当前值；或者能够确保只有单一的线程会修改变量的值。</li>
<li>变量不需要与其他状态变量共同参与不变约束。（这句话有点绕，简单说如果你的判断逻辑中有别的变量参与，那么就需要加锁了）</li>
</ul>
<p>拿一段简单的代码举个例子：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private volatile boolean run;</span><br><span class="line">public void stop()&#123;</span><br><span class="line"><span class="code">    run = false;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">public void run()&#123;</span></span><br><span class="line"><span class="code">    while (run)&#123;</span></span><br><span class="line"><span class="code">        // work</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="无形的锁"><a href="#无形的锁" class="headerlink" title="无形的锁"></a>无形的锁</h5><p>虽然你没有主动使用锁，但在无形中却引入了锁，典型的如高并发方法中频繁访问 <strong>java.util.Properties</strong>，你可知 <strong>Properties 继承于 Hashtable？</strong>类似的还有如下：</p>
<ul>
<li><strong>StringBuffer</strong></li>
<li><strong>Random</strong></li>
<li><strong>Math</strong></li>
<li><strong>Stack</strong></li>
<li><strong>UUID</strong></li>
</ul>
<blockquote>
<p>以上只是遇到过的例子，可能还有很多。简言之：我不杀伯仁，伯仁因我而死。</p>
</blockquote>
<h5 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h5><p>分布式锁的复杂性远超单独语言意义上的锁，常见三种实现方式：</p>
<ul>
<li>数据库</li>
<li>redis</li>
<li>zookeeper</li>
</ul>
<p>在技术选型上，在<strong>低并发场景下可以考虑优先使用基于数据库的乐观锁</strong>，因为够简单、不引入其他组件，但是性能一般。追求高性能可以选择 redis ，如 Java 版本 redLock 的实现 Redisson ，但是需要注意的是集群情况下redLock 可靠性可能没那么强（数据库集群同样需要考虑规避读写分离的场景），具体可以参考Martin写的一篇质疑文章<a target="_blank" rel="noopener" href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html">《How to do distributed locking》</a>。zookeeper可靠性较好（考虑到GC、超时等情况也不是完全可靠），只是性能没这么高。</p>
<p>值得注意的是，<strong>极端情况下分布式锁都不太可靠，需要依赖业务做一定的补偿。</strong></p>
<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>项目中曾经遇到过死锁，所以这里提一嘴，并且强烈建议大家在加锁的时候，<strong>不要使用class作为锁对象</strong>。</p>
<h3 id="Java语言相关"><a href="#Java语言相关" class="headerlink" title="Java语言相关"></a>Java语言相关</h3><p>下面主要是一些踩坑日记，主要是针对Java语言。</p>
<h5 id="class"><a href="#class" class="headerlink" title="class"></a>class</h5><p>高并发代码中使用 <strong>Class</strong> 类要注意，因为 <strong>Class</strong> 中有较多 native 调用，性能开销非常大，常见如：</p>
<ul>
<li><strong>forName</strong></li>
<li><strong>getSimpleName</strong></li>
</ul>
<p>以上是团队在代码中确确实实采过的坑，如果你一定要获取 <strong>Class</strong> 的名称，请使用 <strong>getName 。</strong></p>
<h5 id="string"><a href="#string" class="headerlink" title="string"></a>string</h5><p>我们绝大部分的逻辑或场景都是在处理字符串，太多代码在处理字符串的时候很随意，举一个例子：URL中可能有path包含“&#x2F;&#x2F;”，如“<a target="_blank" rel="noopener" href="http://www.qz.com/query//order%E2%80%9D%E5%8C%85%E5%90%AB%E4%BA%86%E4%B8%A4%E4%B8%AA%E2%80%9C/%E2%80%9D%EF%BC%8C%E4%BA%8E%E6%98%AF%E6%88%91%E4%BB%AC%E5%86%99%E4%BA%86%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%B0%86%E2%80%9C//%E2%80%9D%E5%A4%84%E7%90%86%E4%B8%BA%E2%80%9C/%E2%80%9D%EF%BC%9A">www.qz.com/query//order”包含了两个“/”，于是我们写了一段代码将“//”处理为“/”：</a></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static String replace(String url) &#123;</span><br><span class="line"><span class="code">    int index = url.indexOf(&quot;://&quot;);</span></span><br><span class="line"><span class="code">    if (index &lt;= 0) &#123;</span></span><br><span class="line"><span class="code">        return url;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">    try &#123;</span></span><br><span class="line"><span class="code">        String schema = url.substring(0, index + 3);</span></span><br><span class="line"><span class="code">        String path = url.substring(index + 3)</span></span><br><span class="line"><span class="code">                .replaceAll(&quot;//&quot;, &quot;/&quot;);</span></span><br><span class="line"><span class="code">        return schema + path;</span></span><br><span class="line"><span class="code">    &#125; catch (Exception e) &#123;</span></span><br><span class="line"><span class="code">        return url;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面的代码实测会有1%的CPU损耗，有两个问题：</p>
<ol>
<li>产品的需求是为了将path中带“&#x2F;&#x2F;”的路径替换为&#x2F;，但是这里不管path有没有带“&#x2F;&#x2F;”，直接做了replace。</li>
<li>当然最大的问题还是 String.replaceAll ，贴一段 String.replaceAll 的底层实现应该就可以看出来：</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String replaceAll(String regex, String replacement) &#123;</span><br><span class="line"><span class="code">    return Pattern.compile(regex).matcher(this).replaceAll(replacement);</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h5><p>队列是个不得不说的话题，大家都知道Java内置的一些常用队列如：</p>
<ul>
<li><strong>ArrayBlockingQueue</strong></li>
<li><strong>ConcurrentLinkedQueue</strong></li>
<li><strong>DelayQueue</strong></li>
<li><strong>LinkedBlockingQueue</strong></li>
</ul>
<p>一般场景下这些队列也足够了，但是高并发场景下，我们还有一些更好的选择：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/LMAX-Exchange/disruptor"><strong>disruptor</strong></a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/JCTools/JCTools"><strong>JCTools</strong></a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/netty/netty/blob/b64a6e22b2f410d3092f4a2e9f8edcf8c51262b2/common/src/main/java/io/netty/util/HashedWheelTimer.java"><strong>时间轮实现</strong></a></li>
</ul>
<p>disruptor在 API 团队实际已经有多个组件使用，在性能上有飞速提升，有兴趣的同学可以阅读<a target="_blank" rel="noopener" href="https://tech.meituan.com/2016/11/18/disruptor.html">《高性能队列——Disruptor》</a>。</p>
<h5 id="threadLocal"><a href="#threadLocal" class="headerlink" title="threadLocal"></a>threadLocal</h5><p><strong>ThreadLocal</strong> 在高并发的代码中也很常见，如我们熟悉的 Spring 事务、登录、权限、链路追踪等业务都有他的影子。当遇到需要维护Thread到Object的映射且要保障线程安全时，一种场景选择是使用ConcurrentHashMap，另一种更好的选择就是 <strong>ThreadLocal。</strong>当你想到需要使用 ConcurrentHashMap 时，请务必再思考是否 <strong>ThreadLocal 即可满足场景。</strong>当然 <strong>ThreadLocal</strong>也并非完美，当你意识到 <strong>ThreadLocal</strong>的不完美并有需求改良时，可以看一下netty的设计<a target="_blank" rel="noopener" href="https://github.com/netty/netty/blob/27bfdfb1cd99b0924dea80592ae6f52134be58a3/common/src/main/java/io/netty/util/concurrent/FastThreadLocal.java"><strong>FastThreadLocal</strong></a><strong>。</strong>另外如有子线程读取父线程数据也可以参考 <strong>InheritableThreadLocal</strong> 或者开源的线程池修正版 <strong>TransmittableThreadLocal</strong>。</p>
<h5 id="gc"><a href="#gc" class="headerlink" title="gc"></a>gc</h5><p>如果发现处理数据 QPS 低但是又找不到具体哪个类或方法导致的，建议可以排查一下 <strong>GC</strong>。如何判断当前 <strong>GC</strong> 效率是否是正常？大数据处理场景我们一般看吞吐率（Throughput），GC 吞吐率一般不能低于95%，低于这个值就需要进行JVM调优了，如果排除一些内存溢出的场景，最简单的调优方式就是加内存，事半功倍。GC 参数调优没有固定的方式，一般来说吞吐量优先的应用都有一个很大的新生代和一个较小的老年代。当然如果你追求更高的性能，可以考虑做一些池化处理。内存管理方面可以参考一些优秀的设计如：netty（PoolArena、PoolSubpage、PoolChunk）或 kafka（BufferPool）。</p>
<p>注意吞吐率优先和低延迟的优化手段是不一样的（比如G1或者ZGC可以有效降低延迟，但并不能提升吞吐率）。通常情况下，缩小延迟的代价是降低吞吐量或者消耗更多的内存或者两者同时发生。</p>
<p>顺便再推荐一个在线分析的网站 <a target="_blank" rel="noopener" href="https://gceasy.io/">gceasy</a> 。</p>
<h5 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h5><p>在引入 Spring 或 Spring Boot 框架之前请先思考一个问题：你为什么需要 Spring ？Spring 或 Spring Boot 的一些功能如 IoC、spring-data……会使得效率有飞速提升，但同时必须知道使用 Spring 构建的项目不再保持轻量，无论是在内存还是启动速度上都会有很大的损耗。如果你只是在构建一个很小的项目，或者只是用到了Spring的部分功能（如IoC），可能会有一些更好地替代品，如：IoC替代品Guice、Java云原生Quarkus。</p>
<h5 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h5><p>Java中有大量的 bean 转换场景，如为了优良的防腐设计我们有 PO、VO、DO、DTO 等相互转换，见过很多代码长这样：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BeanUtils.copyProperties(source, target);</span><br></pre></td></tr></table></figure>

<p>甚至这样：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON.parse(JSON.toJSONString(o), MyBean.class);</span><br></pre></td></tr></table></figure>

<p>这两种无一例外性能都很差，如果你不想手写两个类的转换，那你可以试试 <a target="_blank" rel="noopener" href="https://mapstruct.org/">MapStruct</a>，一款基于约定的编译期代码生成器。</p>
<h5 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h5><p>反序列化有时占了我们处理性能消耗的 25% 以上（加上序列化可能更多），甚至很多外场问题反馈性能差都和序列化反序列化有关，这其中的罪魁祸首当然是 JSON，但是很多也有开发滥用的情况，如上例中的 bean 转换，一句简简单单的 JSON.toJSONString 直接将整个性能拉下马。当你在处理JSON上需要消耗很大的性能时，那么你就应该考虑下 <a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf">Protocol Buffers</a>，Google出品从未让人失望，实测处理单条5-10K事件15000QPS，序列化只占 5% 甚至更低的性能损耗。</p>
<h5 id="如何排查性能问题"><a href="#如何排查性能问题" class="headerlink" title="如何排查性能问题"></a>如何排查性能问题</h5><p>说了这么多，当我遇到了性能瓶颈时，该如何排查？可以通过 gc 日志分析，或者下面这款优秀的线上诊断产品 <a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/">arthas</a> 来着手排查。常用的性能排查命令如：trace、profiler……如果你还不知道或者不会用 arthas，那么是时候该学习一下了。某个流程慢可能有多种原因，比如锁、正则回溯、IO、线程数配置不合理等，没有一种方式能找到所有问题，多试试就行了。</p>
<h3 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h3><p>熔断降级是高并发常用的“套路”，团队常常遇到某个正则或者某个解析流程拖慢整个数据处理速度的场景，这时候降级这个手段就派上用场了。为此我们专门设计了一种降级思路，当检测到某个流程（非核心流程） QPS 有显著下降时，对该流程进行降级，但是这过程中也遇到两个问题：</p>
<ol>
<li><strong>如何统计某个流程的QPS？</strong>我们设计了一个基于本地调用的监控方案，用于监控方法级别的耗时QPS。方案思路和网上已有的解决方案如大众点评开源的CAT差不多，只是我们的环境更多的是单机监控，不需要那么重的服务。监控方案设计的要点以及采坑记录参照后面的<a href="#vq8cF">设计模块</a>。</li>
<li><strong>降级阈值设置多少？</strong>阈值设置过高或过低都会影响功能运行。因为我们整个产品的数据处理都是基于Kafka构建，我们通过Kafka消费的积压情况来判定是否需要降级，以及结合整体消费效率和方法预估耗时、实际耗时来判定改方法是否需要降级。</li>
</ol>
<h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><p>Kafka在整个产品数据处理的核心组件，不过我们在Kafka的使用上也存在几个误区（或者说困境）：</p>
<ol>
<li><strong>过度使用 Kafka。</strong>我们将处理流程分为：清洗、采样、风险识别、入库……为了解耦，我们将其中的很多处理流程划分出很多组件，每个组件各司其职，并通过Kafka进行数据传输。这样的系统架构常常导致一个事件（通常会在5-10K大小）会被组件转发到Kafka多个topic，并且有多个不同消费者组消费同一个topic，所以Kafka IO一直居高不下。所以很多架构设计请最好需要遵循简单有效的原则，正如奥卡姆剃刀定律所言：<strong>如无必要，勿增实体。</strong></li>
<li><strong>Kafka 是产品最大的瓶颈。</strong>我们花了一些时间将很多组件的处理流程合并，确实也带来一些性能上的提升。但是后面还是发现 Kafka 是一个瓶颈，且是产品上最大的性能瓶颈。这一个问题直到去年年底才彻底解决，解决的方式说起来其实超级简单：<strong>修改硬件，我们将原先磁盘RAID5或者RAID10改为了RAID0</strong>。没有增加任何成本，事实上Kafka存储的数据也没有这么大的安全性要求。这个事情一直让我思考，为什么我们的优化一直在原地打转，我们是否已经形成了一些固化思维？</li>
<li><strong>Kafka 参数调优。</strong>我们很早之前就尝试过很多参数调优的方式，但是效果甚微，直到后面更换了磁盘阵列。我们 Kafka 的性能瓶颈主要是 <strong>Producer</strong>（有一些流程还是无可避免需要向kafka发送数据），整个调优过程不难，具体的调优参数也不写了，不过我在网上找到一个差不多的案例<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1704059">《记一次 Kafka Producer 性能调优实战》</a>，不会 Kafka Producer 调优的同学可以参考。</li>
</ol>
<blockquote>
<p>我在想存在一种好的思维框架。那是物理学的东西，你知道，有点儿像第一原理推理（first principles reasoning）。总体来讲，我认为存在<strong>将事情缩减至其根本实质</strong>……你必须能够把那些问题“煮沸”才能从里面<strong>找出那些最基本的东西</strong>。</p>
</blockquote>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>我们花在数据库调优的时间上非常少（几乎没有），得益于 mongoDB 强悍的性能以及简单的使用方式，不过这并不意味着我们不会犯错，下面主要是罗列一些团队在使用数据库上所踩的坑。</p>
<h5 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h5><p>人人都知道查询数据需要加索引，但是我见过在这个点上犯错的人却是“人从众”。所以这里再次强调一遍，希望所有研发工程师们可以将<strong>“查询必须走索引”</strong>奉为圭臬。因为一旦有一个走漏的“查询”，所有性能优化付之一炬。当然除了将观念深入人心，还需要建立一个好的规避流程，如：code review、压测环境必须有人观察数据库慢查询日志等。</p>
<h5 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h5><p>我们有很多一次性加载数据的场景，在数据量小的情况下很正常，但是数据量一旦大起来这种方式就需要小心了。在设计批量查询数据方案的时候，我们就应该思考：</p>
<ul>
<li>数据量是否会过万？</li>
<li>单条数据会不会大于10K？</li>
<li>是否会有深分页问题？</li>
<li>能否精简返回的数据字段？</li>
</ul>
<p>另外，针对“深分页问题”，可以尝试下使用ID主键代替 page&#x2F;size查询。</p>
<h5 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h5><p>目前我们团队未使用读写分离，不过读写分离曾经也遇到过坑，所以记录一下，主要是读写分离在高并发时可能会有数据不一致的情况，谨记：<strong>你写入数据在主库，写完立即读（走读库）并非每一次都能马上读到（主从同步有延时）。</strong>如需保持一致，则需要再每次写完后强制读主库，这个强制读的指令可以通过缓存写入一个特殊key实现；或者尝试多长时间后异步延迟更新缓存；或者监听数据库bin log之类。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存是高性能系统设计的一把利剑，但同时也是一把双刃剑，使用时往往需要在性能和一致性之间做好权衡，下面从方面介绍不同的缓存理念以及使用。</p>
<h5 id="Design-Pattern"><a href="#Design-Pattern" class="headerlink" title="Design Pattern"></a>Design Pattern</h5><p>先来理解更新缓存的四种模式：</p>
<ul>
<li><strong>旁路缓存（Cache aside）</strong>最常用的缓存模式，应用程序先从cache取数据，没有读到则从数据库中取数据，成功后放到缓存中；写入时先把数据存到数据库中，成功后再让缓存失效。</li>
<li><strong>读穿透（Read through）</strong>应用程序读数据无需关心数据库或缓存，他统一走缓存服务获取数据，当缓存数据失效时，也由缓存服务自己自己来重新加载数据。热点数据加载一般是此种场景。</li>
<li><strong>写穿透模式（Write through）</strong>所有的写操作都经过缓存，每次向缓存中写数据时，缓存会持久化数据到到数据库，且这两个操作在一个事务中完成。可以保证强一致性，但是性能比较差。</li>
<li><strong>异步缓存写入模式（Write behind caching）</strong>和写穿透模式（Write through）类似，不同的是写入数据时异步持久化到数据库。很多数据库写操作都使用了此种方式，如MySQL 的 InnoDB Buffer Pool 机制。</li>
</ul>
<p>此外，针对 <strong>旁路缓存（Cache aside）</strong> 模式，我们还需要做进一步理解（因为最常用）：</p>
<ul>
<li><strong>写操作为什么要先更新DB再删除缓存。</strong>假设两个线程A和B，线程A写数据前先删除缓存，线程B读不到缓存在并去数据库，同时返回时更新了缓存（A还未写入数据的时候），此时缓存的是旧数据而不是A后面写入的新数据。当然，<strong>先更新DB再删除缓存</strong>理论上来说还是有可能会出现数据不一致性，<strong>不过概率小</strong>：假设两个线程A和B，在缓存刚好失效的场景，A先发起网络请求读取数据，B发起网络请求写数据，B先写成功后删除数据，A读取数据并更新了缓存。<strong>这个场景发生的前提是读数据比写数据慢</strong>，数据库一般读的性能更高，所以这种概率较小。注意：当数据库读写分离时，<strong>更新DB再删除缓存</strong>大概率也会有问题，参考上面数据库。</li>
<li><strong>写操作为什么是删除缓存，而不是更新缓存。 <strong>假设两个线程A和B，A先发起网络请求写入数据A，B再发起请求写入数据B，因为网络抖动等原因B可能先返回，此时缓存数据会被后来的A线程覆盖成了A，导致数据库缓存不一致，此场景对于</strong>删除缓存</strong>方式来说是没有问题的。</li>
<li><strong>其他造成不一致的情况。</strong>删除失败时会出现数据不一致。</li>
</ul>
<h5 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h5><p>远水救不了近火，本地缓存对于应用程序来说是最快也最简单的缓存，所以我们优先考虑使用本地缓存。如果需要用到本地缓存，你可以考虑一些框架，主流的Java本地缓存框架如下：</p>
<ul>
<li><strong>Ehcache</strong></li>
<li><strong>Guava Cache</strong></li>
<li><strong>Caffeine</strong></li>
</ul>
<p>这里首推 <strong>Caffeine</strong>性能最好且纯粹、简单（实现并不简单，可以了解一些底层的算法如：W-TinyLFU、近似频数统计……）。我们使用 <strong>Caffeine</strong> 替换了之前的<strong>Guava Cache</strong>，几乎没付出什么成本，大大降低CPU在缓存上消耗的时间。</p>
<h5 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h5><p>分布式缓存适用于多应用缓存共享的场景，且对一致性要求较高。主流的分布式缓存如下：</p>
<ul>
<li>Redis</li>
<li>Memcached</li>
</ul>
<p>两者的对比可以参考<a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/2873249/is-memcached-a-dinosaur-in-comparison-to-redis">Is memcached a dinosaur in comparison to Redis?</a>，不过我们一般使用Redis，因为支持持久化和更丰富的数据结构。Redis虽快，不过在使用时也遇到一些问题，其中最大的一个问题还是性能问题。如我们经常会缓存一些数据库对象到Redis，整个对象序列化后大小在1-5K左右，使用 <strong>旁路缓存（Cache aside）</strong> 模式查询，但发现 Redis 查询这一步骤的QPS一直不高（只有几千），不是说 Redis 单机轻松百万QPS吗？当然后面也陆续发现了一些使用上的问题：</p>
<ul>
<li>存储大量的对象或未正确设置过期时间，导致 Redis Swap。</li>
<li>选择性能更高的Redis客户端，如：Redisson、Lettuce。性能相关对比只找到这一篇：<a target="_blank" rel="noopener" href="https://dzone.com/articles/redisson-pro-vs-jedis-which-is-faster">Redisson PRO vs. Jedis: Which Is Faster</a>。</li>
<li>序列化和反序列化。特别是大对象，这里是差别很大但也是最容易被忽略的一点，JSON固然好，但是不妨参考上面的<a href="#amYfY">序列化和反序列化</a>。</li>
</ul>
<h5 id="缓存实践"><a href="#缓存实践" class="headerlink" title="缓存实践"></a>缓存实践</h5><p>我们的业务结合了本地和Redis缓存，场景如：计数统计、元数据匹配&#x2F;关联……下面简要地进行说明：</p>
<ul>
<li><strong>计数统计</strong> 最典型的就是访问量统计，针对此类需要做精确计数的场景（如果非精确计数场景也可以参考<a href="#U14hO">频率估计</a>），可以先在本地缓存中使用 <a href="#K6CRt">LongAddr</a> 累加，然后异步定时刷盘到数据库。</li>
<li><strong>元数据匹配&#x2F;关联</strong>举一个最通用的场景，我们的业务就是解析 http 事件并聚合API数据，解析 http 事件这一步高达上万 QPS，不能每次都去数据库关联对应的API，所以需要先匹配缓存，然后匹配数据库。因为QPS非常高且对象很大，为了进一步提高性能，我们优先使用本地缓存来做匹配&#x2F;关联。这种做法也有一个很常见冷启动问题，一旦重启QPS需要一个很长时间的爬坡周期，后来为了应对这种场景我们在启动时会预先加载一部分元数据。不过再这点上也犯过错，详见 <a href="#frwZ0">数据库加载数据</a>。当然后面我们也做了反思，我们真的需要加载所有事件的元数据（API数据）吗？为什么不预先加载一部分热数据让整个爬坡快一点呢？</li>
</ul>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>有时候我们写了很多代码去优化一些问题但是成效往往一般，这时候就需要借助一些算法（魔法）来提效。下面主要是介绍一些大数据算法，以及API团队如何在高并发的场景下运用这些（部分）算法去解决问题。</p>
<h5 id="频率估计"><a href="#频率估计" class="headerlink" title="频率估计"></a>频率估计</h5><p>频率估计（Frequency Estimation）常用于确定某个数据在一个数据集中出现的次数，典型的场景如统计某个用户对网站的访问次数。针对这种场景最简单的方案是使用一个HashMap维护用户和访问计数器，每当有用户访问时将对应的计数器加一，如我们的API访问统计便是此模式。但是这个“土方法”在大数据场景不行，当用户量过大时 HashMap 需要巨大的内存来维护。而频率估计相关算法可以在牺牲一定准确率的前提下优化空间效率，下面介绍几种场景的频率估计算法：</p>
<ul>
<li><strong>Count-Min Sketch</strong>思路和 bloom filter 比较类似, 通过多个 hash 来降低冲突带来的影响，优点是省内存，缺点是对于出现次数比较少的元素，准确性很差。想要进一步了解其原理的可以查看：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fxjwind/p/3289221.html">大数据处理中基于概率的数据结构</a>。</li>
<li><strong>Count-Mean-Min Sketch</strong> Count-Min Sketch 的改进，显著地改善长尾数据的精确度。</li>
<li><strong>AMS Sketch</strong> 相比 Count-Min Sketch 在处理高基数（数据流中不同元素的数量比较大）数据流时准确性更高。</li>
<li><strong>FM Sketch</strong> 快速估计数据流中多维数据的频率和联合概率。参考 <a target="_blank" rel="noopener" href="https://chenju2k6.github.io/blog/2018/02/FM">FM-sketching algorithm</a></li>
</ul>
<h5 id="TopK"><a href="#TopK" class="headerlink" title="TopK"></a>TopK</h5><p>TopK Elements 问题用于找出一组数中最大的 K 个数，也称为 <strong>Heavy Hitters</strong>，这个问题的场景常见于热搜、统计频繁访问等。在数据量不大的场景，可以使用一些计数器或者小根堆的方式去计算最频繁项，但海量数据下由于内存的限制，可以使用一些估计算法解决：</p>
<ul>
<li><strong>Lossy Counting</strong> 整个算法的过程如下（具体也可以参考<a target="_blank" rel="noopener" href="https://micvog.com/2015/07/18/frequency-counting-algorithms-over-data-streams/">这里</a>）：<ol>
<li>维护一个HashMap，并将数据流切分成窗口，窗口的大小由错误率决定。</li>
<li>数据流流入对应的窗口并在HashMap中进行计数直到窗口满，每个元素的频率减1，然后将出现次数为0的元素从HashMap中删除（这一步在实际算法中也见过不将元素递减，而是直接将出现次数小于当前窗口期数的元素移除）。</li>
<li>返回第2步不断循环。</li>
</ol>
</li>
</ul>
<p>Lossy Counting 的空间复杂度会随着流的大小增加，不过可以通过<strong>调整错误容忍度</strong>来控制算法的空间复杂度，当错误容忍度越高时，算法的空间复杂度越低。</p>
<ul>
<li><strong>Sticky Sampling</strong>使用采样的方式进行估计且空间复杂度固定，其算法思想大致流程差不多，可以参考<a target="_blank" rel="noopener" href="https://micvog.com/2015/07/18/frequency-counting-algorithms-over-data-streams/">这里</a>。</li>
<li><strong>Space Saving</strong> 保证准确估计任意给定大小的前 K 个元素出现频率。与 Lossy Counting 相比，如果数据流中存在一些非常频繁的元素，可以考虑使用 Space Saving 算法；如果数据流中存在大量出现次数相近的元素，可以考虑使用Lossy Counting算法（因为 Space Saving 相对更耗内存）。当然还有一些两者的优化版本如：Fast Space Saving 和 Fast Lossy Counting。参考<a target="_blank" rel="noopener" href="https://cse.hkust.edu.hk/~raywong/comp5331/References/EfficientComputationOfFrequentAndTop-kElementsInDataStreams.pdf">这里</a>。</li>
</ul>
<h5 id="基数估计"><a href="#基数估计" class="headerlink" title="基数估计"></a>基数估计</h5><p>我们通常需要统计不同的元素项，比如某个 API 泄露了多少不同的手机号数据、统计独立访客(Unique Visitor - UV)数量等等，一般情况下可以用一个 Set 在内存中做去重计算。但是当数据集过于庞大无法全部放到内存中时，可以尝试使用基数估计算法，在误差可控的情况下对基数进行估计，常见的基数估计算法有<strong>Linear Counting、LogLog Counting、HyperLogLog Counting</strong>及 <strong>Adaptive Counting</strong>等：</p>
<ul>
<li><strong>Linear Counting</strong>使用一个较小的位图来估计唯一元素的数量。它的精度和空间利用率都比较高，但是需要遍历整个数据集来构建位图。</li>
<li><strong>LogLog Counting</strong> 比 Linear Counting 更节省空间，通过对数据进行哈希并计算哈希值的前导零位数来估计唯一元素的数量。虽然它的空间使用率比 Linear Counting 低，但是它的估计精度更高。</li>
<li><strong>HyperLogLog Counting <strong>使用位图和哈希函数来估计唯一元素数量，可以比 LogLog Counting 更好地处理大量数据，它通过对数据进行哈希并计算哈希值的前导零位数来估计唯一元素的数量。</strong>HyperLogLog Counting</strong> 具有更高的估计精度和更低的空间使用率，但是需要一些预处理和参数调整。</li>
<li><strong>Adaptive Counting</strong> 一种改进的基于概率的算法，可以通过动态地调整内部参数来提高估计精度。它可以处理任意大小的数据集，同时具有更高的估计精度和更低的空间使用率。它是一种非常高效的算法，因为它只需要对数据进行一次遍历即可构建模型。一般情况下，<strong>Adaptive Counting</strong> 在小数据量情况下比 <strong>HyperLogLog Counting</strong> 更精准。</li>
</ul>
<h5 id="数据流采样"><a href="#数据流采样" class="headerlink" title="数据流采样"></a>数据流采样</h5><p>采样常用于一些数据量很大但性能不足处理所有数据的场景，比如常见的链路追踪系统，很多都是使用采样来做。如何从一个很大（大到无法放入内存）的数据流中随机地抽取 K 个元素？这是一个经典的数据流采样问题，常见的解法有：<strong>蓄水池采样（Reservoir Sampling）</strong>。</p>
<h5 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h5><p>布隆过滤器主要是为了解决海量数据的存在性问题，海量数据中判定某个数据是否存在且容忍轻微误差这一场景（比如缓存穿透、海量数据去重）来说，非常适合。</p>
<h3 id="其他-effective-建议"><a href="#其他-effective-建议" class="headerlink" title="其他 effective 建议"></a>其他 effective 建议</h3><ol>
<li>热点代码中频繁遍历某个数组（List集合）判断是否包含某个值，思考能否能改成 <strong>Set</strong>。</li>
<li>正则匹配需要高性能时，考虑 Hyperscan，或者使用一些AC（Aho–Corasick）自动机来实现。</li>
</ol>
<blockquote>
<p>后面想到再补充</p>
</blockquote>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>在知乎看了一个讲电磁诱导透明现象的视频，视频讲了什么不重要，倒是结尾处有段话写的很有感触，摘抄一下：或许，物理学的最大魅力就在于大家苦思冥想、绞尽脑汁，最后只研究出了一本《家猪的屠宰方法》，而等待很长一段时间后发现，它竟然可以……屠龙。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《深入理解Java虚拟机》</p>
<p>《Java并发编程艺术》</p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/11/15/java-lock.html">不可不说的Java“锁”事</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dolphin0520/p/3920373.html">Java并发编程：volatile关键字解析</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/jxqlovejava/JavaTopics/blob/master/UUID%E7%9A%84%E6%80%A7%E8%83%BD.md">UUID的性能</a></p>
<p><a target="_blank" rel="noopener" href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html">How to do distributed locking</a></p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2016/11/18/disruptor.html">高性能队列——Disruptor</a></p>
<p><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17416.html">缓存更新的套路</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1136056">Counting Bloom Filter 的原理和实现</a></p>
<p><a target="_blank" rel="noopener" href="https://dirtysalt.github.io/html/probabilistic-data-structures-for-web-analytics-and-data-mining.html">Probabilistic Data Structures for Web Analytics and Data Mining</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fxjwind/p/3289221.html">大数据处理中基于概率的数据结构</a></p>
<p><a target="_blank" rel="noopener" href="https://micvog.com/2015/07/18/frequency-counting-algorithms-over-data-streams/">Frequency Counting Algorithms over Data Streams</a></p>
<p><a target="_blank" rel="noopener" href="https://chenju2k6.github.io/blog/2018/02/FM">FM-sketching algorithm</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/nazeniwaresakini/article/details/109113529">大数据流的在线Heavy Hitters算法（上篇）：基于计数器的方法</a></p>
<p>A. Metwally, D. Agrawal, A. Abbadi, <a target="_blank" rel="noopener" href="http://www.cse.ust.hk/~raywong/comp5331/References/EfficientComputationOfFrequentAndTop-kElementsInDataStreams.pdf">Efficient Computation of Frequent and Top-k Elements in Data Streams</a>, Technical Report 2005-23, University of California, Santa Barbara, 2005.</p>
<p><a target="_blank" rel="noopener" href="https://soulmachine.gitbooks.io/system-design/content/cn/bigdata/">大数据</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.codinglabs.org/articles/cardinality-estimation.html">基数估计算法概览</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.codinglabs.org/articles/algorithms-for-cardinality-estimation-part-i.html">解读Cardinality Estimation算法（第一部分：基本概念）</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.codinglabs.org/articles/algorithms-for-cardinality-estimation-part-ii.html">解读Cardinality Estimation算法（第二部分：Linear Counting）</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.codinglabs.org/articles/algorithms-for-cardinality-estimation-part-iii.html">解读Cardinality Estimation算法（第三部分：LogLog Counting）</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.codinglabs.org/articles/algorithms-for-cardinality-estimation-part-iv.html">解读Cardinality Estimation算法（第四部分：HyperLogLog Counting及Adaptive Counting）</a></p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/10/31/%E7%A0%94%E5%8F%91%E8%AF%84%E5%AE%A1%E6%B5%81%E7%A8%8B/" rel="prev" title="研发评审流程">
                  <i class="fa fa-angle-left"></i> 研发评审流程
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">functm</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
