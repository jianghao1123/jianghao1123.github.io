<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>迷宫式编程</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="迷宫式编程">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="迷宫式编程">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="迷宫式编程">
  
    <link rel="alternative" href="/atom.xml" title="迷宫式编程" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <section id="main">
  
    <article id="post-谈谈Java垃圾收集算法" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/02/谈谈Java垃圾收集算法/">谈谈Java垃圾收集算法</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2019/02/02/谈谈Java垃圾收集算法/" class="article-date">
  <time datetime="2019-02-02T13:26:05.000Z" itemprop="datePublished">2019-02-02</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="三个问题"><a href="#三个问题" class="headerlink" title="三个问题"></a>三个问题</h3><ol>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？</li>
</ol>
<h3 id="哪些内存需要回收？"><a href="#哪些内存需要回收？" class="headerlink" title="哪些内存需要回收？"></a>哪些内存需要回收？</h3><p>&emsp;&emsp;在Java的世界里，使用堆来管理几乎所有的对象实例，要知道那些内存需要回收，必须先知道哪些对象已经死亡，而哪些对象依然存活，由此诞生了两种算法：引用计数和可达性分析。引用计数是一种实现简单且判定效率高的识别算法，但是很难解决对象与对象之间循环引用的问题。所以主流的Java垃圾收集算法都是采用可达性分析算法来判断对象的是否存活。这个算法的基本思路是通过一系列的GC Roots对象作为起始点，从这些节点向下搜索，搜索所走过的路径（Reference Chain），当一个对象没有任何路径可以到达GC Roots时，证明该对象不可用。在Java语言中，可作为GC Roots的对象包括下面几种：</p>
<blockquote>
<ol>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li>
</ol>
</blockquote>
<h3 id="什么时候回收？"><a href="#什么时候回收？" class="headerlink" title="什么时候回收？"></a>什么时候回收？</h3><p>&emsp;&emsp;现代Java虚拟机的GC都是采用的“分代收集算法”，一般把Java堆分为新生代和老年代：新生代存放朝生夕死的对象，老年代存放长寿的对象。要回答这个问题，先从触发GC的时机说起。触发GC的条件一般有两种：系统自动决定GC触发和手动触发GC。</p>
<ol>
<li>系统自动触发GC，一般发生在新对象申请的时候，当Eden空间不足的时候，触发Minor GC，回收不可用的对象。此时Minor GC完成之后，如果Eden空间剩余大小依然不足以分配对象，此时会判断Survivor空间是否充足，如果Survivor空间充足，将Eden空间部分活跃对象保存到Survivor空间，剩余Eden空间存放新对象。当然如果此时Survivor空间不充足，会检查Tenured空间是否充足，如果充足，会将Survivor部分活跃对象保存到Tenured空间，否则触发一次Full GC。</li>
<li>手动触发GC，调用System.gc()的时候触发Full GC，不过需要确保DisableExplicitGC为false。</li>
</ol>
<p>&emsp;&emsp;在触发GC的时候，使用可达性分析对象是否存活。上面在分析哪些内存需要回收的时候说过，不过需要补充一点，即使在可达性分析中作为不可达对象，也不是立即被回收的。要真正宣告一个对象死亡，至少需要经历两次标记过程：如果发现对象没有与GC Roots关联的引用链，那么它会进行第一次标记，并且进行一次筛选。筛选的条件是，该对象是否有必要执行<strong>finalize()</strong>方法：比如对象未覆写<strong>finalize()</strong>，或者已经执行过<strong>finalize()</strong>，那就没有必要执行<strong>finalize()</strong>了，此时该对象就处于要被回收的状态。如果该对象被判定为有必要执行<strong>finalize()</strong>，那么该对象就会被放入一个叫F-Queue的队列中，由虚拟机线程执行<strong>finalize()</strong>。<strong>finalize()</strong>是对象逃离死亡的最后一次机会，比如在<strong>finalize()</strong>中可以将自己赋给GC Roots引用链上的某一个变量，那么，再第二次标记的时候，它就会被移除“即将回收”的集合。否则的话，这个对象基本就是宣告死亡了。</p>
<h3 id="如何回收？"><a href="#如何回收？" class="headerlink" title="如何回收？"></a>如何回收？</h3><p>&emsp;&emsp;在根搜索算法的基础上，现代虚拟机的垃圾收集算法大致有三种：</p>
<ol>
<li>标记-清除算法。</li>
<li>复制算法。</li>
<li>标记-整理算法。</li>
</ol>
<p>&emsp;&emsp;先来说说标记-清除算法。对于这个算法其实有两种说法，我心中也一直有一个疑问。按照《深入理解Java虚拟机》中说：</p>
<blockquote>
<p>算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象</p>
</blockquote>
<p>&emsp;&emsp;维基百科上的说法是标记所有可达对象，回收不可达对象：</p>
<blockquote>
<p>The first stage is the mark stage which does a tree traversal of the entire ‘root set’ and marks each object that is pointed to by a root as being ‘in-use’.</p>
</blockquote>
<p>&emsp;&emsp;在采用标记-清除算法的CMS收集器中，实际上是标记出存活对象，清理掉垃圾对象。那么到底是哪一种准确，亦或者是两种皆可？可以逆向思考一下，假设是标记不可达对象，那么如何标记不可达对象？为了标记一个不可达对象，必然要证明该对象对于所有可达的对象，都是无关联的。所以这样来说，标记不可达对象，其实仍然无法避免需要先标记处出可达对象。<br>&emsp;&emsp;标记-清除算法实现简单，缺点是效率不高，且会造成大量内存碎片。再说说复制算法，复制算法的基本思想是将可用的内存按容量等分成两块。然后每次只使用其中的一块，当这一块快用完的时候，就会触发垃圾回收，它会把还存活的对象全部复制到另外一块内存中去，然后把这块内存全部清理了。复制算法可以很好地解决了标记-清除算法中内存碎片的问题，而且效率也高，但是其自身也有缺点，比如在存活对象较多的场合复制的效率会变慢，而且因为将内存空间进行分块，造成了空间上的浪费。<br>&emsp;&emsp;为了解决存活对象较多复制算法效率变慢的问题，出现了标记-整理算法。标记-整理算法在标记-清除算法的基础上做了一些优化。和标记-清除算法一样，标记-整理算法需要从根节点开始，对所有可达对象做一次标记；但之后，它并不是简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端；之后，清理边界外所有的空间。同标记-清除算法一样，标记-整理的效率也不是很高。<br>&emsp;&emsp;每个算法都有自己的优点和缺点，没有一种垃圾收集算法可以完美地适用于所有垃圾回收的场景。现代商业虚拟机的垃圾收集一般都采用“分代收集”算法。他根据对象的存活周期的不同将内存划分为几块，比如前面已经提到的新生代和老年代。<br>&emsp;&emsp;在新生代中，每次垃圾收集都有大量对象死亡，那么可以采用复制算法，而且依据新生代对象朝生夕死的特点，其实并不需要把空间划分为1:1大小，通常会将内存划分成一块很大的Eden空间和两快较小的Survivor空间，每次使用时只使用Eden空间和其中的一块Survivor空间，当回收时，将Eden空间和Survivor空间存活的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden空间和之前使用的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小为8:1，即只浪费10%空间。但是我们并不能保证每次回收只有不多于10%的对象存活，当Survivor空间不足的时候，就需要依赖老年代空间来做分配担保。前面在什么时候回收中说过Minor GC的触发时机，其实在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果大于，则此次Minor GC是安全的。如果小于且<strong>HandlePromotionFailure=true</strong>，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，则尝试进行一次Minor GC（仍有风险）；如果小于且<strong>HandlePromotionFailure=false</strong>，则改为进行一次Full GC。<br>&emsp;&emsp;老年代中对象存活率高，采用标记-清除或者标记整理算法。这里我们以CMS收集器作为例子，简单看一下标记-清除算法是如何进行的。CMS收集器一般分为以下几个步骤：</p>
<ol>
<li>InitialMarking（初始标记，整个过程STW）</li>
<li>Marking（并发标记）</li>
<li>Precleaning（预清理）</li>
<li>AbortablePreclean（可中断的预清理）</li>
<li>FinalMarking（重新标记，STW过程）</li>
<li>ConcurrentSweep(并发清除)</li>
</ol>
<p>可以看到CMS收集器有三次标记，初始标记仅标记了GC Roots能直接关联到的对象，并发标记遍历初始标记阶段标记出来的存活对象，然后继续递归标记这些对象可达的对象。而重新标记是因为并发标记阶段是和用户线程并行执行的，在这期间的用户线程有可能改变了部分对象的引用关系。经过多轮标记，最后阶段由收集器并发清除掉未标记的对象。</p>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-谈谈高并发之分页缓存的设计" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/02/谈谈高并发之分页缓存的设计/">谈谈高并发之分页缓存的设计</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2019/02/02/谈谈高并发之分页缓存的设计/" class="article-date">
  <time datetime="2019-02-02T13:25:48.000Z" itemprop="datePublished">2019-02-02</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h3><p>&emsp;&emsp;在策划印记读书（小程序）这款小产品的时候，考虑到一些问题，比如如何去设计一个针对文章列表的分页缓存系统。在这过程中也总结了一些业务的需求点：</p>
<ol>
<li>后台发布文章，马上展示到新用户的首页，首页的文章按照发布的时间降序排列。</li>
<li>某个用户浏览首页的时候，不要出现重复的文章，过程中也不要丢失文章。</li>
<li>文章会有点赞、评论等操作，列表展示文章的点赞数和评论数。</li>
<li>从用户体验的角度讲，尽量缩短首屏的加载时间。</li>
</ol>
<h3 id="客户端缓存"><a href="#客户端缓存" class="headerlink" title="客户端缓存"></a>客户端缓存</h3><p>&emsp;&emsp;从第4点的用户体验上来说，最先考虑的是客户端缓存。比如客户端加载了一页数据，可以把它缓存到本地，当用户退出再次进入页面的时候，先加载本地的缓存数据，然后再去请求服务端的新数据。这样的设计有几个要点：</p>
<ol>
<li>必须记下缓存中最新的文章，基于此（比如最新文章的主键）来请求服务器增量更新数据。</li>
<li>当上拉加载的时候，为了避免服务器返回重复的数据，需要记下缓存中最旧的文章，基于此加载列表之前的数据。</li>
<li>基于以上两点，必须保证本地文章列表的连贯性，即下拉刷新返回的文章，必须和本地缓存是连贯的，中间不能出现断层，不然会出现文章丢失的情况。</li>
</ol>
<p>当然这里的缓存也不能是无限制缓存，不然首屏加载了缓存中大量的数据，在小程序上可能出现卡顿的现象。最好还是只缓存最新的一页数据，这样也可以降低后续分页的复杂性。</p>
<h3 id="服务器缓存"><a href="#服务器缓存" class="headerlink" title="服务器缓存"></a>服务器缓存</h3><p>&emsp;&emsp;考虑一个最简单的数据库分页，取page和size，在分页的过程中假设新增了一条数据，会出现什么情况？这种场景无可避免地会让用户刷到重复的文章，比如A文章本来是在第一页的最后一项，用户请求第一页拉取了A，正要请求第二页数据，这时候更新了一篇文章B，这条临时插入的数据无疑让A文章再次出现在用户的第二页中。不过这个问题在考虑客户端缓存设计中的第二点，其实已经解决了。<br>&emsp;&emsp;当后台发布文章的时候，同步将文章加入到缓存中。用户对文章的点赞评论操作，同样也会更新缓存中的数据。基于这两个要素，设计列表缓存的时候，可以考虑将列表数据进行拆分。即将列表数据分拆分成两个篮子，其中一个篮子装列表主键专门用于分页，一个篮子装具体的列表item项。假设使用redis作为缓存层，可以使用zset来存储列表主键，zset的score可以使用文章主键或者创建时间戳来作为排序依据。每次客户端请求数据的时候，都会携带page、size和当前数据项的标记，服务器先从列表主键缓存中查找一页数据，然后可以依据查找到的主键从文章缓存中索引到具体的文章。</p>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-RocketMQ之旅（七）broker处理消息" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/01/RocketMQ之旅（七）broker处理消息/">RocketMQ之旅（七）broker处理消息</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2019/02/01/RocketMQ之旅（七）broker处理消息/" class="article-date">
  <time datetime="2019-02-01T13:00:12.000Z" itemprop="datePublished">2019-02-01</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/RocketMQ之旅/">RocketMQ之旅</a>
  </div>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="消息接收"><a href="#消息接收" class="headerlink" title="消息接收"></a>消息接收</h4><p>&emsp;&emsp;在<strong>BrokerController</strong>的<strong>registerProcessor()</strong>中，注册了很多网络处理器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * SendMessageProcessor</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    SendMessageProcessor sendProcessor = <span class="keyword">new</span> SendMessageProcessor(<span class="keyword">this</span>);</span><br><span class="line">    sendProcessor.registerSendMessageHook(sendMessageHookList);</span><br><span class="line">    sendProcessor.registerConsumeMessageHook(consumeMessageHookList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.remotingServer.registerProcessor(RequestCode.SEND_MESSAGE, sendProcessor, <span class="keyword">this</span>.sendMessageExecutor);</span><br><span class="line">    <span class="keyword">this</span>.remotingServer.registerProcessor(RequestCode.SEND_MESSAGE_V2, sendProcessor, <span class="keyword">this</span>.sendMessageExecutor);</span><br><span class="line">    <span class="keyword">this</span>.remotingServer.registerProcessor(RequestCode.SEND_BATCH_MESSAGE, sendProcessor, <span class="keyword">this</span>.sendMessageExecutor);</span><br><span class="line">    <span class="keyword">this</span>.remotingServer.registerProcessor(RequestCode.CONSUMER_SEND_MSG_BACK, sendProcessor, <span class="keyword">this</span>.sendMessageExecutor);</span><br><span class="line">    <span class="keyword">this</span>.fastRemotingServer.registerProcessor(RequestCode.SEND_MESSAGE, sendProcessor, <span class="keyword">this</span>.sendMessageExecutor);</span><br><span class="line">    <span class="keyword">this</span>.fastRemotingServer.registerProcessor(RequestCode.SEND_MESSAGE_V2, sendProcessor, <span class="keyword">this</span>.sendMessageExecutor);</span><br><span class="line">    <span class="keyword">this</span>.fastRemotingServer.registerProcessor(RequestCode.SEND_BATCH_MESSAGE, sendProcessor, <span class="keyword">this</span>.sendMessageExecutor);</span><br><span class="line">    <span class="keyword">this</span>.fastRemotingServer.registerProcessor(RequestCode.CONSUMER_SEND_MSG_BACK, sendProcessor, <span class="keyword">this</span>.sendMessageExecutor);</span><br><span class="line">    <span class="comment">// ...省略部分的注册逻辑...</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<strong>SendMessageProcessor</strong>主要负责接收Producer发过来的消息，继承于NettyRequestProcessor，每个继承于NettyRequestProcessor的子类都需要实现<strong>processRequest()</strong>：<br>
        
          <p class="article-more-link">
            <a href="/2019/02/01/RocketMQ之旅（七）broker处理消息/#more">More...</a>
          </p>
        
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-算法国（二）字符串匹配" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/17/算法国（二）字符串匹配/">算法国（二）字符串匹配</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/12/17/算法国（二）字符串匹配/" class="article-date">
  <time datetime="2018-12-17T14:22:55.000Z" itemprop="datePublished">2018-12-17</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/算法国/">算法国</a>
  </div>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;&emsp;本故事除了算法纯属虚构。</p>
<blockquote>
<p><strong>算法就是思考的方式</strong></p>
</blockquote>
<h4 id="很长的开头"><a href="#很长的开头" class="headerlink" title="很长的开头"></a>很长的开头</h4><p>&emsp;&emsp;很久以前，算法国的人只知道0和1。有一天，来了一个外国人，外国人会一种新奇的语言，它简单却又多变，生动而且内涵，它有二十六个字母组成，对比可怜又枯燥的0和1，这实在太有趣了！算法国的人一下子爱上了这种语言。外国人很开心算法国的人喜欢他们的语言，于是他很慷慨地教他们，他大笔一挥，写下算法国第一行外文：</p>
<blockquote>
<p><strong>“Hello World。”</strong></p>
</blockquote>
        
          <p class="article-more-link">
            <a href="/2018/12/17/算法国（二）字符串匹配/#more">More...</a>
          </p>
        
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-RocketMQ之旅（六）broker启动" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/17/RocketMQ之旅（六）broker启动/">RocketMQ之旅（六）broker启动</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/12/17/RocketMQ之旅（六）broker启动/" class="article-date">
  <time datetime="2018-12-17T14:22:41.000Z" itemprop="datePublished">2018-12-17</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/RocketMQ之旅/">RocketMQ之旅</a>
  </div>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="命令行启动"><a href="#命令行启动" class="headerlink" title="命令行启动"></a>命令行启动</h4><p>&emsp;&emsp;先从官方的一段启动命令开始我们的旅程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; nohup sh bin/mqbroker -n localhost:<span class="number">9876</span> &amp;</span><br><span class="line">&gt; tail -f ~/logs/rocketmqlogs/broker.log </span><br><span class="line">The broker[%s, <span class="number">172.30</span>.30.233:<span class="number">10911</span>] boot success...</span><br></pre></td></tr></table></figure></p>
<p>mqbroker脚本放在distribution模块的bin目录下。贴一下该脚本的启动命令语句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh $&#123;ROCKETMQ_HOME&#125;/bin/runbroker.sh org.apache.rocketmq.broker.BrokerStartup $@</span><br></pre></td></tr></table></figure></p>
<p>从这句sh命令可知，mqbroker脚本主要是启动broker模块的<strong>BrokerStartup</strong>，<strong>BrokerStartup</strong>是整个broker的入口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    start(createBrokerController(args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
        
          <p class="article-more-link">
            <a href="/2018/12/17/RocketMQ之旅（六）broker启动/#more">More...</a>
          </p>
        
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-RocketMQ之旅（五）remoting" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/19/RocketMQ之旅（五）remoting/">RocketMQ之旅（五）remoting</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/11/19/RocketMQ之旅（五）remoting/" class="article-date">
  <time datetime="2018-11-19T09:02:22.000Z" itemprop="datePublished">2018-11-19</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/RocketMQ之旅/">RocketMQ之旅</a>
  </div>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;&emsp;之前不论是分析namesrv模块还是client模块，都意外地碰到了remoting模块的代码，remoting是RocketMQ公用的网络处理模块，使用netty框架编写，所以我觉得有必要先来看一下remoting模块的代码，正好可以将之前跳过去的网络传输部分补齐，也可以为之后的代码分析做好铺垫。或者你如果想要用netty来做点什么，正好可以来借鉴一下，看一看在RocketMQ中，这个成熟的开源框架是如何来使用Netty的。remoting模块主要分成两个部分，服务端和客户端，从应用上来说，服务端是<strong>NettyRemotingServer</strong>，客户端是<strong>NettyRemotingClient</strong>，只要从这两个类上着手就可以了。</p>
<h4 id="NettyRemotingServer"><a href="#NettyRemotingServer" class="headerlink" title="NettyRemotingServer"></a>NettyRemotingServer</h4><p>&emsp;&emsp;NettyRemotingServer在RocketMQ中主要用在两个地方，BrokerController和NamesrvController，先来看一下类图：<br><img src="http://ww1.sinaimg.cn/large/639cfad5gy1fxbb18isgtj20ri0go0vk.jpg" alt=""><br>
        
          <p class="article-more-link">
            <a href="/2018/11/19/RocketMQ之旅（五）remoting/#more">More...</a>
          </p>
        
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-算法国（一）排序" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/17/算法国（一）排序/">算法国（一）排序</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/11/17/算法国（一）排序/" class="article-date">
  <time datetime="2018-11-17T11:39:02.000Z" itemprop="datePublished">2018-11-17</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/算法国/">算法国</a>
  </div>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;&emsp;本故事除了算法纯属虚构。</p>
<blockquote>
<p><strong>在算法国里面，谁掌握的算法越多，谁就是王。</strong></p>
</blockquote>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>&emsp;&emsp;排序是最基础的算法，在算法国连小孩都会，什么，如果你连一个排序算法都不会，呵，那人家就会喊你码农，哦不对，码农现在高级了，那叫你码畜，也不对，可能他们会直接喊码拉格比，你连个排序都不会？当然，连排序算法都不会一个的人，在算法国是找不到工作的。算法国的工作其实很简单，复制算法，然后粘贴算法。当然，有时候需要改造一下算法。那已经是比较高级的工作了。至于能创造算法的人，他就是神。<br>
        
          <p class="article-more-link">
            <a href="/2018/11/17/算法国（一）排序/#more">More...</a>
          </p>
        
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-RocketMQ之旅（四）client之Consumer" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/12/RocketMQ之旅（四）client之Consumer/">RocketMQ之旅（四）client之Consumer</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/11/12/RocketMQ之旅（四）client之Consumer/" class="article-date">
  <time datetime="2018-11-12T07:54:12.000Z" itemprop="datePublished">2018-11-12</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/RocketMQ之旅/">RocketMQ之旅</a>
  </div>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="官方示例"><a href="#官方示例" class="headerlink" title="官方示例"></a>官方示例</h4><p>&emsp;&emsp;先看一下Consumer的类图结构：<br><img src="http://ww1.sinaimg.cn/large/639cfad5ly1fwno96uqyvj20ta0j20wf.jpg" alt=""><br>Consumer按照拉取的方式分为MQPullConsumer和MQPushConsumer，先从一个官网的MQPushConsumer示例开始：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, MQClientException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Instantiate with specified consumer group name.</span></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// Specify name server addresses.</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">"localhost:9876"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Subscribe one more more topics to consume.</span></span><br><span class="line">        consumer.subscribe(<span class="string">"TopicTest"</span>, <span class="string">"*"</span>);</span><br><span class="line">        <span class="comment">// Register callback to execute on arrival of messages fetched from brokers.</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                System.out.printf(<span class="string">"%s Receive New Messages: %s %n"</span>, Thread.currentThread().getName(), msgs);</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Launch the consumer instance.</span></span><br><span class="line">        consumer.start();</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"Consumer Started.%n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
        
          <p class="article-more-link">
            <a href="/2018/11/12/RocketMQ之旅（四）client之Consumer/#more">More...</a>
          </p>
        
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-RocketMQ之旅（三）client之Producer" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/25/RocketMQ之旅（三）client之Producer/">RocketMQ之旅（三）client之Producer</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/10/25/RocketMQ之旅（三）client之Producer/" class="article-date">
  <time datetime="2018-10-25T05:49:21.000Z" itemprop="datePublished">2018-10-25</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/RocketMQ之旅/">RocketMQ之旅</a>
  </div>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="从官方示例开始"><a href="#从官方示例开始" class="headerlink" title="从官方示例开始"></a>从官方示例开始</h3><p>&emsp;&emsp;先从一个官网的同步消息发送示例开始：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//Instantiate with a producer group name.</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span></span><br><span class="line">            DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">        <span class="comment">// Specify name server addresses.</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">"localhost:9876"</span>);</span><br><span class="line">        <span class="comment">//Launch the instance.</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//Create a message instance, specifying topic, tag and message body.</span></span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                <span class="string">"TagA"</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                (<span class="string">"Hello RocketMQ "</span> +</span><br><span class="line">                    i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">            );</span><br><span class="line">            <span class="comment">//Call send message to deliver message to one of brokers.</span></span><br><span class="line">            SendResult sendResult = producer.send(msg);</span><br><span class="line">            System.out.printf(<span class="string">"%s%n"</span>, sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Shut down once the producer instance is not longer in use.</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
        
          <p class="article-more-link">
            <a href="/2018/10/25/RocketMQ之旅（三）client之Producer/#more">More...</a>
          </p>
        
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-Netty之旅（十二）EventLoop" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/08/Netty之旅（十二）EventLoop/">Netty之旅（十二）EventLoop</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/10/08/Netty之旅（十二）EventLoop/" class="article-date">
  <time datetime="2018-10-08T09:51:59.000Z" itemprop="datePublished">2018-10-08</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Netty之旅/">Netty之旅</a>
  </div>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Reactor线程模型"><a href="#Reactor线程模型" class="headerlink" title="Reactor线程模型"></a>Reactor线程模型</h3><p>&emsp;&emsp;<strong>Netty之旅（七）从官方例子展开</strong>中的例子有这么一段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br></pre></td></tr></table></figure></p>
<p>这也是我们初次接触EventLoop的地方。这两句有什么用？想要理解这两句的意义，不得不说一下Reactor的线程模型。Reactor 线程模型有三种:</p>
<ol>
<li>单线程。历史是循序渐进的，Reactor的线程模型发展也是循序渐进的。单线程是最简单的线程模型，Reactor线程无所不能，一边负责多路套接字的分离，接受新的链接，处理I/O操作，一边分配请求到不同的处理器进行消息编解码处理业务。可以很容易地看出单线程模型的缺陷，在同一个线程，一旦哪里有阻塞，整个系统都不得动弹。</li>
<li>多线程。多线程模型是对单线程的改进，我们将负责监听连接处理I/O的操作和业务处理器分开了。有一个专门的Reactor线程，处理连接和I/O操作，也有专门的业务处理线程池。</li>
<li>主从多线程。高并发环境下，Reactor线程要同时处理成百上千的链路，既要监听连接还要处理I/O，性能上无法支撑。这时候将Reactor分离，有一个主Reactor线程负责连接的监听，另有一个从Reactor线程池负责处理I/O。</li>
</ol>
<p>这里的bossGroup和workerGroup就是两个Reactor线程池，一个用于网络链路连接，另一个是处理I/O读写，或者是一些系统的定时任务。<br>
        
          <p class="article-more-link">
            <a href="/2018/10/08/Netty之旅（十二）EventLoop/#more">More...</a>
          </p>
        
      

      
        
    </div>
  </div>
  
</article>



  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        <aside id="sidebar">
  <nav class="menus">
  	<ul>
  		<li><a href="/"><i class="icon icon-home"></i></a></li>
  		
			<li><a href="/archives"><i class="icon icon-fenlei"></i></a></li>
  		
  		
			<li><a href="/tags"><i class="icon icon-tag"></i></a></li>
  		
  		
  			<li><a href="https://github.com/hejianxian" target="_blank"><i class="icon icon-github"></i></a></li>
  		
  	</ul>
  </nav>
  <a id="go-top" href="#"><i class="icon icon-up"></i></a>
</aside>

      </div>
      <footer id="footer">
  
	<div id="footer-info" class="inner">
	  &copy; 2019 matrix22 
	  - Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
	  - Theme <a href="https://github.com/hejianxian/hexo-theme-jane/" target="_blank">Jane</a>
	</div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/tags" class="mobile-nav-link">Tag</a>
  
    <a href="https://github.com/hejianxian" class="mobile-nav-link">Github</a>
  
</nav>
    

<script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>