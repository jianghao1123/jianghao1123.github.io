<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="编程" />










<meta property="og:type" content="website">
<meta property="og:title" content="迷宫式编程">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="迷宫式编程">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="迷宫式编程">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>迷宫式编程</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">迷宫式编程</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-主页">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-主页"></i> <br />
            
            主页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-所有文章">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-文章"></i> <br />
            
            所有文章
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/30/Java基础（一）CountDownLatch源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="matrix22">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷宫式编程">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/30/Java基础（一）CountDownLatch源码分析/" itemprop="url">Java并发之旅（一）CountDownLatch源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-30T13:48:28+08:00">
                2018-07-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h3><p>&emsp;&emsp;CountDownLatch的源码其实很简单，因为其主要依靠<strong>AQS</strong>实现（所以AQS不简单，大部分代码都会进入AQS讲解）。CountDownLatch由一个内部静态类Sync继承AQS。分析整个CountDownLatch的源码，抓住两个函数入口即可，一个是<strong>await()</strong>,一个是<strong>countDown()</strong>。当然为了熟悉这两个方法的环境，先来看下AQS的实现Sync：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// java.util.concurrent.CountDownLatch.Sync</span><br><span class="line">private static final class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        private static final long serialVersionUID = 4982264981922014374L;</span><br><span class="line">        // AQS中鼎鼎有名的state</span><br><span class="line">        Sync(int count) &#123;</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int getCount() &#123;</span><br><span class="line">            return getState();</span><br><span class="line">        &#125;</span><br><span class="line">        // 这个方法会经常调用，如果state=0，证明可以唤醒等待线程了</span><br><span class="line">        protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">            return (getState() == 0) ? 1 : -1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 尝试去释放锁，调用CountDown()方法会调用此方法，将state-1</span><br><span class="line">        protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">            // Decrement count; signal when transition to zero</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                int c = getState();</span><br><span class="line">                if (c == 0)</span><br><span class="line">                    return false;</span><br><span class="line">                int nextc = c-1;</span><br><span class="line">                if (compareAndSetState(c, nextc))</span><br><span class="line">                    return nextc == 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="await-方法"><a href="#await-方法" class="headerlink" title="await()方法"></a>await()方法</h3><p>&emsp;&emsp;下面直面主题，先来看下<strong>await()</strong>方法具体做了什么事，其实具体还是调用了AQS中的方法，我是代码的搬运工：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// java.util.concurrent.CountDownLatch.Sync</span><br><span class="line">public void await() throws InterruptedException &#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br><span class="line">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">            throws InterruptedException &#123;</span><br><span class="line">        if (Thread.interrupted())</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        // 参见Sync中的代码解释，第一次进来，如果不需要等待，await线程就直接进行下去了，不需要阻塞</span><br><span class="line">        if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">            doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>doAcquireSharedInterruptibly()</strong> 是重点方法（后面会讲到很多次，这个大概就是迷宫的入口了），讲这个方法之前，简单说一下AQS，我是代码的搬运工（网上抄一份，解释的比我通顺多了）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">//java.util.concurrent.locks.AbstractQueuedSynchronizer.Node</span><br><span class="line">    ...................</span><br><span class="line">/**</span><br><span class="line"> * Node 是AQS的内部静态类</span><br><span class="line"> * AQS主要的概念就是队列，队列里面就是节点，节点差不多长这个样子 </span><br><span class="line"> */</span><br><span class="line">static final class Node &#123;</span><br><span class="line">    /** waitStatus value to indicate thread has cancelled */</span><br><span class="line">    static final int CANCELLED =  1;</span><br><span class="line">    /** waitStatus value to indicate successor&apos;s thread needs unparking */</span><br><span class="line">    static final int SIGNAL    = -1;</span><br><span class="line">    /** waitStatus value to indicate thread is waiting on condition */</span><br><span class="line">    static final int CONDITION = -2;</span><br><span class="line">    /**</span><br><span class="line">     * waitStatus value to indicate the next acquireShared should</span><br><span class="line">     * unconditionally propagate</span><br><span class="line">     */</span><br><span class="line">    static final int PROPAGATE = -3; </span><br><span class="line">    /** Marker to indicate a node is waiting in shared mode */</span><br><span class="line">    static final Node SHARED = new Node();</span><br><span class="line">    /** Marker to indicate a node is waiting in exclusive mode */</span><br><span class="line">    static final Node EXCLUSIVE = null;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    *注意：</span><br><span class="line">    *分为两种类型的结点：共享模式结点 与 排他模式结点。</span><br><span class="line">    *对于任何类型的结点，初始状态waitStatus均为0</span><br><span class="line">     等待状态：</span><br><span class="line">     *-SIGNAL(-1):</span><br><span class="line">     *  后继结点处于等待状态，</span><br><span class="line">     *  如果当前线程释放的同步状态或者被中断，</span><br><span class="line">     *  将会通知后继结点，使后继结点线程运行</span><br><span class="line">     * </span><br><span class="line">     *-CANCELLED(1):</span><br><span class="line">     *  同步队列中等待的线程等待超时或者被中断，需要从同步队列中取消等待</span><br><span class="line">     *</span><br><span class="line">     *-CONDITION(-2):</span><br><span class="line">     *  结点在等待队列中，结点线程等待在这个Condition上，</span><br><span class="line">     *  当其他线程对这个Condition对象调用signal()\signalAll()，</span><br><span class="line">     *  则这个结点将进入等待队列中移入同步队列中，准备重试获取同步状态;</span><br><span class="line">     *</span><br><span class="line">     *-PROPAGATE(-3)</span><br><span class="line">     *</span><br><span class="line">     *-INITIAL(0):</span><br><span class="line">     *  初始状态</span><br><span class="line">     *</span><br><span class="line">     *</span><br><span class="line">     *;PROPAGATE;</span><br><span class="line">     */</span><br><span class="line">    volatile int waitStatus;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 前驱结点 </span><br><span class="line">     */</span><br><span class="line">    volatile Node prev;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 后继结点</span><br><span class="line">     */</span><br><span class="line">    volatile Node next;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取同步状态的线程</span><br><span class="line">     */</span><br><span class="line">    volatile Thread thread;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 等待队列中的后继结点。</span><br><span class="line">     */</span><br><span class="line">    Node nextWaiter;</span><br><span class="line">    ...................</span><br></pre></td></tr></table></figure></p>
<p>下面再来看看AQS长啥样，主要看AQS三个参数，其他的先忽略了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 因为AQS就是队列，这里就是队列的头结点</span><br><span class="line">private transient volatile Node head;</span><br><span class="line">// 队列的尾节点</span><br><span class="line">private transient volatile Node tail;</span><br><span class="line">// 鼎鼎有名的 state（CountDownLatch中count就是这个state）</span><br><span class="line">private volatile int state;</span><br></pre></td></tr></table></figure></p>
<p>再来看下主角方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line">private void doAcquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">        // 加入AQS豪华队列阵容</span><br><span class="line">        final Node node = addWaiter(Node.SHARED);</span><br><span class="line">        boolean failed = true;</span><br><span class="line">        try &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                final Node p = node.predecessor();</span><br><span class="line">                if (p == head) &#123;</span><br><span class="line">                    int r = tryAcquireShared(arg);</span><br><span class="line">                    if (r &gt;= 0) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = null; // help GC</span><br><span class="line">                        failed = false;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    throw new InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>逐行代码分析，这个方法一开头先加入一个<strong>SHARED</strong>节点，SHARED节点在Node中是一个常量，于此还有一个<strong>EXCLUSIVE</strong>节点，顾名思义，一个代表共享，一个代表独占。<br>先来看一下<strong>addWaiter()</strong>方法干了什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line">// 上面传来的是 SHARED 节点，这里直接调用Node的构造函数，</span><br><span class="line">// 将Node里面的nextWaiter设置为SHARED，这里没什么用，略过</span><br><span class="line">// 刚进来反正这里tail=null,我们直接看下面的enq方法</span><br><span class="line">// 返回SHARED节点</span><br><span class="line">private Node addWaiter(Node mode) &#123; </span><br><span class="line">        Node node = new Node(Thread.currentThread(), mode);</span><br><span class="line">        Node pred = tail;</span><br><span class="line">        if (pred != null) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node);</span><br><span class="line">        return node;</span><br><span class="line">&#125;</span><br><span class="line">// 入队操作来了，AQS中喜闻乐见，先来一个死循环。</span><br><span class="line">// 这个方法很绕啊，我们第一次进来，tail=null，直接看compareAndSetHead </span><br><span class="line">// compareAndSetHead其实是使用CAS设置AQS的头结点，这里把新建的Node赋给head头结点</span><br><span class="line">// 顺便把新建的Node也赋给了AQS的tail尾节点</span><br><span class="line">// 这还不够，因为在for中循环，我们重来一次，现在 tail != null 了</span><br><span class="line">// 这里把刚传递进来的SHARED节点的prev参数指向刚才新建的Node节点</span><br><span class="line">// 然后又把SHARED节点赋给了tail节点（compareAndSetTail当然是用CAS为tail赋值）</span><br><span class="line">// 然后新建的Node节点的next参数指向了SHARED节点，返回了新建的Node节点（即head）</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 来来去去，好了AQS内部的队列模型出来了，CountDownLatch好像并没有发挥AQS队列的威力</span><br><span class="line"> * 就是这么简单了</span><br><span class="line"> *</span><br><span class="line"> *      +---------+       +------+ </span><br><span class="line"> * head |新建的Node|       |SHARED|  tail</span><br><span class="line">        |  next   |&lt;-----&gt;| pre  |</span><br><span class="line"> *      +---------+       +------+  </span><br><span class="line"> **/</span><br><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            if (t == null) &#123; // Must initialize</span><br><span class="line">                if (compareAndSetHead(new Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    return t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>又进入恐怖游轮，我们回过头再看<strong>doAcquireSharedInterruptibly()</strong>方法内部中的死循环。第一次循环演练，我们拿SHARED节点的前置节点，看AQS队列可知是head节点，方便查看，再复制一遍代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line">private void doAcquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">        // 前面已经加入AQS豪华队列阵容</span><br><span class="line">        final Node node = addWaiter(Node.SHARED);</span><br><span class="line">        boolean failed = true;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 星辰大海，从for循环的第一次说起</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                // 首次循环 拿到SHARED节点的前置节点，当然就是head节点了</span><br><span class="line">                final Node p = node.predecessor();</span><br><span class="line">                // 表达式成立，进入这个if中</span><br><span class="line">                if (p == head) &#123;</span><br><span class="line">                    // 再次查看state状态</span><br><span class="line">                    // tryAcquireShared 返回就两个值 如果需要阻塞，r=-1，不需要阻塞，r=1</span><br><span class="line">                    int r = tryAcquireShared(arg);</span><br><span class="line">                    // 不需要阻塞了，await线程接下去要干啥</span><br><span class="line">                    // 剧透一下，其实接下来的代码啥也没干，await线程不阻塞了能干嘛</span><br><span class="line">                    // 看这个方法直接return出死循环，自己去干自己的事情了</span><br><span class="line">                    if (r &gt;= 0) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = null; // help GC</span><br><span class="line">                        failed = false;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    throw new InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看到await线程不需要阻塞，来看看具体干了啥事，只要看下<strong>setHeadAndPropagate()</strong>这个方法，代码的搬运工：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line">/**</span><br><span class="line"> * 参数node是addWaiter方法返回值，即SHARED节点，propagate=1</span><br><span class="line"> * 这个方法其实主要是释放AQS队列，后面会继续讲到如何释放</span><br><span class="line">**/</span><br><span class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">        Node h = head; // Record old head for check below</span><br><span class="line">        // 把 SHARED 节点给了head</span><br><span class="line">        setHead(node);</span><br><span class="line">        // 这个方法直接进来了，因为propagate=1</span><br><span class="line">        if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||</span><br><span class="line">            (h = head) == null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">            Node s = node.next;</span><br><span class="line">            // SHARED 节点的next节点为空，doReleaseShared方法调用</span><br><span class="line">            if (s == null || s.isShared())</span><br><span class="line">                doReleaseShared();</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>强行再进入到doReleaseShared() 方法中看一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">        // 又见迷之死循环</span><br><span class="line">        // 这个方法好像啥也没干…直接break跳出死循环</span><br><span class="line">        // 没关系，我们还会见面的</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            // 这个方法进不来了，因为上一步把 SHARED 节点给了head</span><br><span class="line">            // tail节点也是 SHARED 哦</span><br><span class="line">            if (h != null &amp;&amp; h != tail) &#123;</span><br><span class="line">                int ws = h.waitStatus;</span><br><span class="line">                if (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                        continue;            // loop to recheck cases</span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                else if (ws == 0 &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                    continue;                // loop on failed CAS</span><br><span class="line">            &#125;</span><br><span class="line">            if (h == head)                   // loop if head changed</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一顿操作，其实啥事也没干哦，接下来再看下<strong>doAcquireSharedInterruptibly()</strong> 方法中的 <strong>shouldParkAfterFailedAcquire()</strong> 函数干了啥：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line">// 参数pred为head节点 </span><br><span class="line">// 参数node为SHARED节点</span><br><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">        // head节点的waitStatus一直没设置过哦，初始默认为0</span><br><span class="line">        // ws=0，进入最后一个else</span><br><span class="line">        int ws = pred.waitStatus;</span><br><span class="line">        if (ws == Node.SIGNAL)</span><br><span class="line">            return true;</span><br><span class="line">        if (ws &gt; 0) &#123;</span><br><span class="line">            do &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 把head结点的 waitStatus设置为SIGNAL，从今以后，head节点的waitStatus=SIGNAL了</span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>言归正传，继续看 <strong>doAcquireSharedInterruptibly()</strong>方法，这次我们假设 <strong>tryAcquireShared()</strong>返回-1，接下来要阻塞了，看一下上面 <strong>doAcquireSharedInterruptibly()</strong>函数，需要阻塞的时候，竟然还是会调用 <strong>shouldParkAfterFailedAcquire()</strong>，哦，接下来发生的事情一模一样，我们head结点的waitStatus被设置为了SIGNAL，并且由于shouldParkAfterFailedAcquire返回false，我们会第二次进入循环中。再次进入循环的话，当然我们还是假设await线程会阻塞（因为不会阻塞的话就直接跳出循环了），这次 <strong>shouldParkAfterFailedAcquire()</strong>不负众望，head节点的waitStatus因为在第一次循环被设置为了SIGNAL，这个方法直接返回true了，很好，我们进入 <strong>parkAndCheckInterrupt()</strong>方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line">// await线程终于可以休息了</span><br><span class="line">// LockSupport.park的意思就是把当前线程挂起</span><br><span class="line">// 调用await方法的线程，整个世界在这里被暂停了</span><br><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">        LockSupport.park(this);</span><br><span class="line">        return Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>好了，awiat()方法到这里暂停了，await整个线程被阻塞在这里，注意，线程是被阻塞在for循环里面，一旦被唤醒，继续迷之循环。</p>
<h3 id="countDown-方法"><a href="#countDown-方法" class="headerlink" title="countDown()方法"></a>countDown()方法</h3><p>到这里我们终于可以松口气，看下两大重要方法中的另外一个方法<strong>countDown()</strong>，这个方法比较简单，就是调用了Sync类中的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line">// 每次调用countDown()，就是释放一下共享锁</span><br><span class="line">// 这里传入的arg参数恒为1</span><br><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">        // 如果启动await线程，会调用doReleaseShared，这个方法上面遇到过了，老朋友。</span><br><span class="line">        if (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br><span class="line">// java.util.concurrent.CountDownLatch.Sync</span><br><span class="line">// releases参数恒为1</span><br><span class="line">// state=0会返回true，代表await线程可以满血复活了</span><br><span class="line">protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">            // 迷之死循环，CAS交换的温室</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                int c = getState();</span><br><span class="line">                // 非法调用countDown()太多次了，怎么能忍心让state成为负数，随便返回个false给你</span><br><span class="line">                if (c == 0)</span><br><span class="line">                    return false;</span><br><span class="line">                // 让state（其实就是count）减1，然后CAS交换</span><br><span class="line">                int nextc = c-1;</span><br><span class="line">                if (compareAndSetState(c, nextc))</span><br><span class="line">                    return nextc == 0;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 再贴一下老朋友</span><br><span class="line">// 不过上一次见面，他什么都没干，终于又见面了</span><br><span class="line">/**</span><br><span class="line"> * 顺便再看下我们AQS的队列</span><br><span class="line"> *</span><br><span class="line"> *      +---------+       +------+ </span><br><span class="line"> * head |新建的Node|       |SHARED|  tail</span><br><span class="line">        |  next   |&lt;-----&gt;| pre  |</span><br><span class="line"> *      +---------+       +------+  </span><br><span class="line"> **/</span><br><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            // 反正这里 h == head 都成立，最后总能结束</span><br><span class="line">            Node h = head;</span><br><span class="line">            // head=Node  tail=SHARED</span><br><span class="line">            // 第一次进来等式肯定成立的，进去看看</span><br><span class="line">            // 剧透：从后面看如果await线程已经被其他线程唤醒了，就会变成head=tail=SHARED</span><br><span class="line">            if (h != null &amp;&amp; h != tail) &#123;</span><br><span class="line">                int ws = h.waitStatus;</span><br><span class="line">                // head节点的waitStatus早就是SIGNAL了，等式成立，再进去看看</span><br><span class="line">                if (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    // 如果head的waitStatus已经被别人篡改了</span><br><span class="line">                    // 那么啥事也不做，继续循环</span><br><span class="line">                    // 如果当前countDown线程顺利的话，head的waitStatus=SIGNAL,CAS交换成功了</span><br><span class="line">                    // 严正警戒：这个时候head节点的waitStatus=0一切又重归原样</span><br><span class="line">                    // 最后调用unparkSuccessor()</span><br><span class="line">                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                        continue;            // loop to recheck cases</span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                else if (ws == 0 &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                    continue;                // loop on failed CAS</span><br><span class="line">            &#125;</span><br><span class="line">            if (h == head)                   // loop if head changed</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>假设线程一切顺利，<strong>unparkSuccessor()</strong>方法被调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line">// node参数为head节点，注意他的waitStatus因为CAS交换，又变为0了</span><br><span class="line">// 这个方法存在的意义，当然是唤醒我们的await线程了</span><br><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">        int ws = node.waitStatus;</span><br><span class="line">        if (ws &lt; 0)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line">        // head的下一个节点，当然是SHARED(tail)节点了</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        // 很遗憾都不成立</span><br><span class="line">        if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">            s = null;</span><br><span class="line">            for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                if (t.waitStatus &lt;= 0)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        // 好了，一切顺利的结局，await线程被唤醒。</span><br><span class="line">        if (s != null)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>await线程被唤醒了，前面说了await线程其实一直被阻塞在一个for循环里面，一旦被人唤醒，迷之for循环又开始了，还是再贴一遍<strong>doAcquireSharedInterruptibly()</strong>这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line">private void doAcquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">        final Node node = addWaiter(Node.SHARED);</span><br><span class="line">        boolean failed = true;</span><br><span class="line">        try &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                // await方法被唤醒，再次进入循环</span><br><span class="line">                // 拿到SHARED节点的前置节点，当然还是head节点了</span><br><span class="line">                final Node p = node.predecessor();</span><br><span class="line">                if (p == head) &#123;</span><br><span class="line">                    // 这里的r当然是1了，因为我们是被唤醒的，被唤醒的条件就是tryAcquireShared返回1</span><br><span class="line">                    int r = tryAcquireShared(arg);</span><br><span class="line">                    // 似曾相识，我们再次进入这个方法，其实后面要发生的事情前面已经说过了</span><br><span class="line">                    // head节点next指针，</span><br><span class="line">                    if (r &gt;= 0) &#123;</span><br><span class="line">                        // 把head指向SHARED，释放新建的Node</span><br><span class="line">                        // 从此以后，head==tail==SHARED</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        // 这里新建的Node的next指针不再指向SHARED了</span><br><span class="line">                        // 这个help GC感觉没什么用哦</span><br><span class="line">                        p.next = null; // help GC</span><br><span class="line">                        failed = false;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    throw new InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 顺便再看下我们AQS的队列</span><br><span class="line"> *</span><br><span class="line"> *      +---------+       +------+ </span><br><span class="line"> * head |新建的Node|       |SHARED|  tail</span><br><span class="line">        |  next   |&lt;-----&gt;| pre  |</span><br><span class="line"> *      +---------+       +------+  </span><br><span class="line"> *</span><br><span class="line"> * 经过这个方法之后，我们的队列就变成了这样（SHARED不需要被释放，因为他是静态常量）</span><br><span class="line"> *</span><br><span class="line"> *      +---------+</span><br><span class="line"> * head | SHARED  | tail</span><br><span class="line"> *      |         |</span><br><span class="line"> *      +---------+</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * 参数node是addWaiter方法返回值，即SHARED节点，propagate=1</span><br><span class="line"> * </span><br><span class="line"> * 把head指向SHARED，释放新建的Node，释放线程引用</span><br><span class="line"> *</span><br><span class="line">**/</span><br><span class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">        Node h = head; // Record old head for check below</span><br><span class="line">        // 把 SHARED 节点给了head</span><br><span class="line">        // 并且把SHARED的pre置为null（如此这般就释放了之前新建的Node节点）</span><br><span class="line">        setHead(node);</span><br><span class="line">        // 这个方法直接进来了，因为propagate=1</span><br><span class="line">        if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||</span><br><span class="line">            (h = head) == null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">            Node s = node.next;</span><br><span class="line">            // SHARED 节点的next节点为空，doReleaseShared方法调用</span><br><span class="line">            if (s == null || s.isShared())</span><br><span class="line">                doReleaseShared();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void setHead(Node node) &#123;</span><br><span class="line">        head = node;</span><br><span class="line">        node.thread = null;</span><br><span class="line">        node.prev = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;学习了Doug Lea大神的源码后，什么函数式编程，面向对象编程，一切都觉过眼云烟，所有的函数方法存在的意义，都是为了重用。你在层层重用面前，从这个方法跳到另外一个方法，当你觉得终于达到了终点的时候，一切其实又回到了原点。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/28/Netty修行（三）ByteBuf内存管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="matrix22">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷宫式编程">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/28/Netty修行（三）ByteBuf内存管理/" itemprop="url">Netty修行（三）ByteBuf内存三剑客以及算法概要</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-28T18:02:39+08:00">
                2018-07-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="内存分配器ByteBufAllocator"><a href="#内存分配器ByteBufAllocator" class="headerlink" title="内存分配器ByteBufAllocator"></a>内存分配器ByteBufAllocator</h3><p>&emsp;&emsp;ByteBufAllocator是ByteBuf的内存分配器，下面是其实现：<br><img src="http://ww1.sinaimg.cn/large/639cfad5gy1fts8nj8gyvj20s80c43zi.jpg" alt="Alt text"><br>UnpooledByteBufAllocator不说了，这里主要是探讨一下PooledByteBufAllocator。PooledByteBufAllocator是池化空间的内存分配器，其内部实际依赖于PoolArena来分配内存。PoolArena是我们内存管理的第一剑客，为了提高并发效率，PooledByteBufAllocator可以有多个PoolArena来分配内存，下面是默认的堆内存PoolArena数量和直接内存PoolArena数量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">final int defaultMinNumArena = NettyRuntime.availableProcessors() * 2;</span><br><span class="line">final int defaultChunkSize = DEFAULT_PAGE_SIZE &lt;&lt; DEFAULT_MAX_ORDER;</span><br><span class="line">DEFAULT_NUM_HEAP_ARENA = Math.max(0,</span><br><span class="line">        SystemPropertyUtil.getInt(</span><br><span class="line">                &quot;io.netty.allocator.numHeapArenas&quot;,</span><br><span class="line">                (int) Math.min(</span><br><span class="line">                        defaultMinNumArena,</span><br><span class="line">                        runtime.maxMemory() / defaultChunkSize / 2 / 3)));</span><br><span class="line">DEFAULT_NUM_DIRECT_ARENA = Math.max(0,</span><br><span class="line">        SystemPropertyUtil.getInt(</span><br><span class="line">                &quot;io.netty.allocator.numDirectArenas&quot;,</span><br><span class="line">                (int) Math.min(</span><br><span class="line">                        defaultMinNumArena,</span><br><span class="line">                        PlatformDependent.maxDirectMemory() / defaultChunkSize / 2 / 3)));</span><br></pre></td></tr></table></figure></p>
<p><strong>DEFAULT_PAGE_SIZE</strong>默认为8192，<strong>DEFAULT_MAX_ORDER</strong>默认为11，这两个常量很重要，跟后面的内存管理息息相关。来看下PooledByteBufAllocator实际分配heapBuffer的地方：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">protected ByteBuf newHeapBuffer(int initialCapacity, int maxCapacity) &#123;</span><br><span class="line">        // 优先获取线程缓存的 PoolArena，这就是上面说为什么有多个PoolArena</span><br><span class="line">        PoolThreadCache cache = threadCache.get();</span><br><span class="line">        PoolArena&lt;byte[]&gt; heapArena = cache.heapArena;</span><br><span class="line"></span><br><span class="line">        final ByteBuf buf;</span><br><span class="line">        if (heapArena != null) &#123;</span><br><span class="line">            // 使用PoolArena来获取ByteBuf</span><br><span class="line">            buf = heapArena.allocate(cache, initialCapacity, maxCapacity);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 第一次进来，线程没有PoolArena缓存，直接返回一个未池化的ByteBuf</span><br><span class="line">            buf = PlatformDependent.hasUnsafe() ?</span><br><span class="line">                    new UnpooledUnsafeHeapByteBuf(this, initialCapacity, maxCapacity) :</span><br><span class="line">                    new UnpooledHeapByteBuf(this, initialCapacity, maxCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return toLeakAwareBuffer(buf);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>PoolArena</strong>虽然是实际的内存操纵者，但是，他自己却不干活，实质上也是一个管理者，来看下它内部的劳工<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private final PoolSubpage&lt;T&gt;[] tinySubpagePools;</span><br><span class="line">private final PoolSubpage&lt;T&gt;[] smallSubpagePools;</span><br><span class="line">private final PoolChunkList&lt;T&gt; q050;</span><br><span class="line">private final PoolChunkList&lt;T&gt; q025;</span><br><span class="line">private final PoolChunkList&lt;T&gt; q000;</span><br><span class="line">private final PoolChunkList&lt;T&gt; qInit;</span><br><span class="line">private final PoolChunkList&lt;T&gt; q075;</span><br><span class="line">private final PoolChunkList&lt;T&gt; q100;</span><br></pre></td></tr></table></figure></p>
<p>由此，Netty的内存三剑客差不多已经浮出了水面，其中一位便是<strong>PoolSubpage</strong>，不过还有一位并不是这里的PoolChunkList，因为进入PoolChunkList我又发现了一位劳工，三剑客之一<strong>PoolChunk</strong>。因为实质上PoolChunkList的引入就是为了更高效的管理PoolChunk，他组成了劳工的工会。至此，<strong>PoolArena</strong>、<strong>PoolSubpage</strong>、<strong>PoolChunk</strong>便组成了我们的内存三剑客。</p>
<h3 id="Netty内存管理概要"><a href="#Netty内存管理概要" class="headerlink" title="Netty内存管理概要"></a>Netty内存管理概要</h3><h4 id="Buddy算法和Slab机制"><a href="#Buddy算法和Slab机制" class="headerlink" title="Buddy算法和Slab机制"></a>Buddy算法和Slab机制</h4><p>&emsp;&emsp;Buddy算法利用计算机可以快速计算2次幂的特性，将内存中的页按照2^N划分，比如把内存分为1，2，4，8，16，32，64……个连续页，每个页有一定大小。假设一个页4KB大小，为了申请1M大小的空间，可以先从256页框去查找，如果该页框空间不足2M大小，就从512的页框查找，如果该页框空闲，会被一分为二，并将其中的一块分配给用户使用。被拆分后的两个小块，就是伙伴了。下面是一个完整的示例：<br><img src="http://ww1.sinaimg.cn/large/639cfad5gy1ftz5koynqyj20gm09m3zh.jpg" alt="Alt text"><br>简单解释下，假设分配70K大小空间，因为页都是2次幂，所以实际上需要给他分配128K大小。接着分配35K大小，初始128K被分配了，256K被一分为二，剩余的128继续拆分，分成两个64K大小……如此循环往复，去寻找相匹配的页。<br>&emsp;&emsp;从上面Buddy算法来看，虽然分配连续内存空间的效率很高，但是也因为2次幂的特性，导致空间被浪费，如果用来分配小内存空间，那就更加浪费了，因为Buddy分配内存大小是以页为单位的。比如我们要分配10B大小，总不能直接给分配一页空间吧。所以，为了解决小内存分配的问题，有了Slab机制。Slab是一个对象缓存池，他就像一个零售店，从Buddy那里批发内存，对象是他的基本商品。</p>
<h4 id="jemalloc内存分配"><a href="#jemalloc内存分配" class="headerlink" title="jemalloc内存分配"></a>jemalloc内存分配</h4><p>&emsp;&emsp;Netty的内存设计很大程度上借鉴了jemalloc，比如<strong>Arena</strong>和<strong>Thread Cache</strong>。<strong>Arena</strong>是一个完全自治的区域，他将内存页划分为<strong>Chunk</strong>，多个页构成一个<strong>Chunk</strong>，比如在jemalloc中建议<strong>Chunk</strong>为4MB大小。<strong>Arena</strong>内部维护了一个bin数组，bin中有多个Run，一个Run就是Chunk内的一块区域，每个Run大于等于一个Page，根据Page Run的内存使用率，将其分为QINIT，Q0，Q25，Q50，Q75，Q100，使用率分组参照下面：<br><img src="http://ww1.sinaimg.cn/large/639cfad5gy1fu0bnudmx4j20ho0c13z6.jpg" alt="Alt text"><br>bin还管理着内存的分配方式，它根据内存大小分为三个尺寸，分别是<strong>small</strong>，<strong>large</strong>，<strong>huge</strong>，具体参照下图：<br><img src="http://ww1.sinaimg.cn/large/639cfad5gy1fu0clp6lz8j20940cvdgd.jpg" alt="Alt text"><br>&emsp;&emsp;<strong>Thread Cache</strong>保证多线程并发下更高效地分配内存，每个<strong>Thread Cache</strong>对应一个<strong>Arena</strong>（通常有多个Arena），同时其内部还维护了<strong>small</strong>的缓存，每次分配小内存的时候，都会优先检测本地缓存，更有效地消除了锁竞争的开销。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/28/Netty修行（二）ByteBuf引用计数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="matrix22">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷宫式编程">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/28/Netty修行（二）ByteBuf引用计数/" itemprop="url">Netty修行（二）ByteBuf引用计数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-28T17:07:16+08:00">
                2018-07-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>&emsp;&emsp;当我们创建一个对象的时候，对象的引用计数为1。当有一个其他对象指向该对象时，通过retain该对象使其引用计数+1，如果某个对象不再指向该对象时，通过release该对象使其引用计数-1。当该对象的引用计数为0的时候，说明该对象可以被销毁了。<br>&emsp;&emsp;Java既然已经有了很优秀的内存回收算法了，为什么Netty还要使用引用计数？究其原因，可以从以下两点分析：</p>
<ol>
<li>ByteBuf可以从直接内存上分配，直接内存不会由JVM直接控制。创建和释放Direct Buffer的代价要比Heap Buffer高很多，使用引用计数可以大大提高内存的释放效率。</li>
<li>池化Bytebuf也是提高Netty内存分配的一种手段，为了更方便的管理这个对象池，使用引用计数也是一个好的办法。</li>
</ol>
<hr>
<h3 id="AbstractReferenceCountedByteBuf实现"><a href="#AbstractReferenceCountedByteBuf实现" class="headerlink" title="AbstractReferenceCountedByteBuf实现"></a>AbstractReferenceCountedByteBuf实现</h3><p>&emsp;&emsp;Netty的引用计数主要依靠AbstractReferenceCountedByteBuf实现，AbstractReferenceCountedByteBuf内部通过一个AtomicIntegerFieldUpdater变量来实现引用计数。每一次调用retain()方法，引用计数就会+1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private ByteBuf retain0(final int increment) &#123;</span><br><span class="line">        int oldRef = refCntUpdater.getAndAdd(this, increment);</span><br><span class="line">        if (oldRef &lt;= 0 || oldRef + increment &lt; oldRef) &#123;</span><br><span class="line">            // Ensure we don&apos;t resurrect (which means the refCnt was 0) and also that we encountered an overflow.</span><br><span class="line">            refCntUpdater.getAndAdd(this, -increment);</span><br><span class="line">            throw new IllegalReferenceCountException(oldRef, increment);</span><br><span class="line">        &#125;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>对应使用release()方法使得引用计数-1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private boolean release0(int decrement) &#123;</span><br><span class="line">        int oldRef = refCntUpdater.getAndAdd(this, -decrement);</span><br><span class="line">        if (oldRef == decrement) &#123;</span><br><span class="line">            deallocate();</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else if (oldRef &lt; decrement || oldRef - decrement &gt; oldRef) &#123;</span><br><span class="line">            // Ensure we don&apos;t over-release, and avoid underflow.</span><br><span class="line">            refCntUpdater.getAndAdd(this, decrement);</span><br><span class="line">            throw new IllegalReferenceCountException(oldRef, -decrement);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果引用计数为0，调用deallocate()方法进行清理内存。deallocate()是一个虚函数，由各自的ByteBuf来具体实现不同的内存清理方法，比如最简单的UnpooledHeapByteBuf，他的deallocate()就是将数组赋值为空：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected void deallocate() &#123;</span><br><span class="line">        freeArray(array);</span><br><span class="line">        array = EmptyArrays.EMPTY_BYTES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/28/Netty修行之ByteBuf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="matrix22">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷宫式编程">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/28/Netty修行之ByteBuf/" itemprop="url">Netty修行（一）ByteBuf简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-28T10:24:06+08:00">
                2018-07-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="NIO-Buffer缺陷"><a href="#NIO-Buffer缺陷" class="headerlink" title="NIO Buffer缺陷"></a>NIO Buffer缺陷</h3><ol>
<li>Buffer设计精简，只有一个position。读写切换的时候需要使用者手动去调用flip()和rewind()，其position和limit的含义，取决于当前Buffer是处于读还是写模式，无疑为整个Buffer编程增加难度。</li>
<li>ByteBuffer长度固定，一旦长度超出limit就会抛出IndexOutOfBoundsException，这就意味着在为ByteBuffer分配容量的时候，你必须精确地知道数据的长度，或者明确知道不会超出某个长度。当然，你也可以自己为ByteBuffer封装功能，实现类似数组扩容的逻辑。</li>
</ol>
<hr>
<h3 id="ByteBuf介绍"><a href="#ByteBuf介绍" class="headerlink" title="ByteBuf介绍"></a>ByteBuf介绍</h3><p>&emsp;&emsp;ByteBuf是一个接口，可以看一下ByteBuf的主要实现：<br><img src="http://ww1.sinaimg.cn/large/639cfad5gy1ftro5mxzrcj21d80qytbh.jpg" alt="Alt text"><br>&emsp;&emsp;基于内存分配，ByteBuf分为direct（直接内存）和heap（堆内存），heap由JVM控制管理，直接内存不会直接由JVM回收。基于内存回收，ByteBuf又分为pool（池化）和unPool（非池化），pool可以重用ByteBuf。<br>&emsp;&emsp;为了改进NIO的Buffer的position，ByteBuf设计了两个“position”，读操作使用writerIndex，写操作使用readerIndex，两者互不影响。初始化的的ByteBuf如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+---------------------------------------------------------+</span><br><span class="line">|                       writable bytes                    |</span><br><span class="line">+---------------------------------------------------------+</span><br><span class="line">|                                                         |</span><br><span class="line">0 = readerIndex = writerIndex            &lt;=            capacity</span><br></pre></td></tr></table></figure></p>
<p>往ByteBuf写入数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+------------------+------------------+</span><br><span class="line">|  readable bytes  |  writable bytes  |</span><br><span class="line">+------------------+------------------+</span><br><span class="line">|                  |                  |</span><br><span class="line">0=readerIndex &lt; writerIndex   &lt;=   capacity</span><br></pre></td></tr></table></figure></p>
<p>开始读ByteBuf中的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+------------------+------------------+</span><br><span class="line">| discardable bytes |  readable bytes  |  writable bytes  |</span><br><span class="line">+-------------------+------------------+------------------+</span><br><span class="line">|                   |                  |                  |</span><br><span class="line">0      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=    capacity</span><br></pre></td></tr></table></figure></p>
<p>这时候多了一个discardable bytes，这段空间的数据是之前已读的，可以调用discardReadBytes()回收内存：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+------------------+--------------------------------------+</span><br><span class="line">|  readable bytes  |    writable bytes (got more space)   |</span><br><span class="line">+------------------+--------------------------------------+</span><br><span class="line">|                  |                                      |</span><br><span class="line">readerIndex (0) &lt;= writerIndex (decreased)       &lt;=   capacity</span><br></pre></td></tr></table></figure></p>
<p>或者可以使用clear()回收内存：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+---------------------------------------------------------+</span><br><span class="line">|             writable bytes (got more space)             |</span><br><span class="line">+---------------------------------------------------------+</span><br><span class="line">|                                                         |</span><br><span class="line">0 = readerIndex = writerIndex            &lt;=            capacity</span><br></pre></td></tr></table></figure></p>
<p>ByteBuf在写数据的时候，会进行容量检测：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">final void ensureWritable0(int minWritableBytes) &#123;</span><br><span class="line">        ensureAccessible();</span><br><span class="line">        if (minWritableBytes &lt;= writableBytes()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (minWritableBytes &gt; maxCapacity - writerIndex) &#123;</span><br><span class="line">            throw new IndexOutOfBoundsException(String.format(</span><br><span class="line">                    &quot;writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d): %s&quot;,</span><br><span class="line">                    writerIndex, minWritableBytes, maxCapacity, this));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Normalize the current capacity to the power of 2.</span><br><span class="line">        int newCapacity = alloc().calculateNewCapacity(writerIndex + minWritableBytes, maxCapacity);</span><br><span class="line"></span><br><span class="line">        // Adjust to the new capacity.</span><br><span class="line">        capacity(newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>扩容策略由ByteBufAllocator执行，具体可以看AbstractByteBufAllocator中的calculateNewCapacity()方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public int calculateNewCapacity(int minNewCapacity, int maxCapacity) &#123;</span><br><span class="line">    if (minNewCapacity &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;minNewCapacity: &quot; + minNewCapacity + &quot; (expected: 0+)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (minNewCapacity &gt; maxCapacity) &#123;</span><br><span class="line">        throw new IllegalArgumentException(String.format(</span><br><span class="line">                &quot;minNewCapacity: %d (expected: not greater than maxCapacity(%d)&quot;,</span><br><span class="line">                minNewCapacity, maxCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">    final int threshold = CALCULATE_THRESHOLD; // 4 MiB page</span><br><span class="line"></span><br><span class="line">    if (minNewCapacity == threshold) &#123;</span><br><span class="line">        return threshold;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If over threshold, do not double but just increase by threshold.</span><br><span class="line">    if (minNewCapacity &gt; threshold) &#123;</span><br><span class="line">        int newCapacity = minNewCapacity / threshold * threshold;</span><br><span class="line">        if (newCapacity &gt; maxCapacity - threshold) &#123;</span><br><span class="line">            newCapacity = maxCapacity;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            newCapacity += threshold;</span><br><span class="line">        &#125;</span><br><span class="line">        return newCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Not over threshold. Double up to 4 MiB, starting from 64.</span><br><span class="line">    int newCapacity = 64;</span><br><span class="line">    while (newCapacity &lt; minNewCapacity) &#123;</span><br><span class="line">        newCapacity &lt;&lt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return Math.min(newCapacity, maxCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法计算出一个新的容量大小，首先设置了一个4MB的阈值，从64字节开始，每次以倍增的方式扩容，64字节，128字节，256字节……如果超过4MB的阈值，扩容放弃倍增的策略，以4MB为步长累加。这个扩容策略有点像TCP的慢启动-拥塞控制。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/22/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="matrix22">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷宫式编程">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/22/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-22T22:27:37+08:00">
                2018-07-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">matrix22</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">matrix22</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
