<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>迷宫式编程</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="迷宫式编程">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="迷宫式编程">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="迷宫式编程">
  
    <link rel="alternative" href="/atom.xml" title="迷宫式编程" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <section id="main">
  
    <article id="post-Netty之旅（十二）EventLoop" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/08/Netty之旅（十二）EventLoop/">Netty之旅（十二）EventLoop</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/10/08/Netty之旅（十二）EventLoop/" class="article-date">
  <time datetime="2018-10-08T09:51:59.000Z" itemprop="datePublished">2018-10-08</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Netty之旅/">Netty之旅</a>
  </div>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Reactor线程模型"><a href="#Reactor线程模型" class="headerlink" title="Reactor线程模型"></a>Reactor线程模型</h3><p>&emsp;&emsp;<strong>Netty之旅（七）从官方例子展开</strong>中的例子有这么一段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br></pre></td></tr></table></figure></p>
<p>这也是我们初次接触EventLoop的地方。这两句有什么用？想要理解这两句的意义，不得不说一下Reactor的线程模型。Reactor 线程模型有三种:</p>
<ol>
<li>单线程。历史是循序渐进的，Reactor的线程模型发展也是循序渐进的。单线程是最简单的线程模型，Reactor线程无所不能，一边负责多路套接字的分离，接受新的链接，处理I/O操作，一边分配请求到不同的处理器进行消息编解码处理业务。可以很容易地看出单线程模型的缺陷，在同一个线程，一旦哪里有阻塞，整个系统都不得动弹。</li>
<li>多线程。多线程模型是对单线程的改进，我们将负责监听连接处理I/O的操作和业务处理器分开了。有一个专门的Reactor线程，处理连接和I/O操作，也有专门的业务处理线程池。</li>
<li>主从多线程。高并发环境下，Reactor线程要同时处理成百上千的链路，既要监听连接还要处理I/O，性能上无法支撑。这时候将Reactor分离，有一个主Reactor线程负责连接的监听，另有一个从Reactor线程池负责处理I/O。</li>
</ol>
<p>这里的bossGroup和workerGroup就是两个Reactor线程池，一个用于网络链路连接，另一个是处理I/O读写，或者是一些系统的定时任务。<br>
        
          <p class="article-more-link">
            <a href="/2018/10/08/Netty之旅（十二）EventLoop/#more">More...</a>
          </p>
        
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-Netty之旅（十一）ChannelHandler" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/25/Netty之旅（十一）ChannelHandler/">Netty之旅（十一）ChannelHandler</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/09/25/Netty之旅（十一）ChannelHandler/" class="article-date">
  <time datetime="2018-09-25T08:41:05.000Z" itemprop="datePublished">2018-09-25</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Netty之旅/">Netty之旅</a>
  </div>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>&emsp;&emsp;ChannelHandler应该是用户使用netty接触最多的组件，他的继承类也比较多，子类实现功能多不胜数，所以只列下一些基类，如下：<br><img src="http://ww1.sinaimg.cn/large/639cfad5gy1fv33xjyn28j212u0i8q4u.jpg" alt=""><br>&emsp;&emsp;根据事件在ChannelPipline中的流向，ChannelHandler按照出入站将事件分为两类，ChannelInboundHandler和ChannelOutboundHandler。<br>
        
          <p class="article-more-link">
            <a href="/2018/09/25/Netty之旅（十一）ChannelHandler/#more">More...</a>
          </p>
        
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-Netty之旅（十）ChannelHandlerContext" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/08/Netty之旅（十）ChannelHandlerContext/">Netty之旅（十）ChannelHandlerContext</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/09/08/Netty之旅（十）ChannelHandlerContext/" class="article-date">
  <time datetime="2018-09-08T02:25:23.000Z" itemprop="datePublished">2018-09-08</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Netty之旅/">Netty之旅</a>
  </div>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;&emsp;<strong>Netty之旅（九）ChannelPipeline</strong>中我们知道ChannelPipeline的事件接收后真正处理者是ChannelHandlerContext，所以围绕前文，我们来探讨一下ChannelHandlerContext是如何处理这些事件的。ChannelHandlerContext的类图也很简单：<br><img src="http://ww1.sinaimg.cn/large/639cfad5ly1fuv6uq2j3gj21640modmg.jpg" alt=""><br>
        
          <p class="article-more-link">
            <a href="/2018/09/08/Netty之旅（十）ChannelHandlerContext/#more">More...</a>
          </p>
        
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-Netty之旅（九）ChannelPipeline" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/08/Netty之旅（九）ChannelPipeline/">Netty之旅（九）ChannelPipeline</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/09/08/Netty之旅（九）ChannelPipeline/" class="article-date">
  <time datetime="2018-09-08T02:25:08.000Z" itemprop="datePublished">2018-09-08</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Netty之旅/">Netty之旅</a>
  </div>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>&emsp;&emsp;ChannelPipeline和ChannelHandler实现了一种Intercepting Filter Pattern（拦截过滤器）。每一个netty Channel都有他自己的ChannelPipeline，当Channel收到事件，他就会将事件传递给自己的ChannelPipeline，事件在ChannelPipeline中流动，从一个ChannelHandler传播到下一个ChannelHandler。源码里面有一个经典的流动图可以解释：<br>
        
          <p class="article-more-link">
            <a href="/2018/09/08/Netty之旅（九）ChannelPipeline/#more">More...</a>
          </p>
        
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-Netty之旅（八）Channel" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/27/Netty之旅（八）Channel/">Netty之旅（八）Channel</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/27/Netty之旅（八）Channel/" class="article-date">
  <time datetime="2018-08-27T13:03:42.000Z" itemprop="datePublished">2018-08-27</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Netty之旅/">Netty之旅</a>
  </div>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;&emsp;这里的Channel是<strong>io.netty.channel.Channel</strong>，很巧合的是java nio里面也有一个Channel——<strong>java.nio.channels.Channel</strong>，这两者有什么关系？同样是接口，也同样是实现I/O操作的通道，java nio中的Channel异常简单，只有两个方法，<strong>isOpen()</strong>，<strong>close()</strong>，剩下的功能诸如I/O读写，都是交给其子类接口去实现，所有的Channel接口功能都被细分了。netty中的Channel却特别复杂，内部的方法大概是nio中所有Channel子类的总和……也就是说，netty中的Channel，聚合了nio所有Channel分散的方法。两种截然不同的设计思想，不能说好坏，从接口设计的角度讲，nio中的Channel当然更加优雅——每个Channel的子类职责单一，分工明确。不过从使用的角度来说，netty显然更胜一筹，大而全的接口设计，总是让人一目了然，<strong>NioServerSocketChannel</strong>或者<strong>NioSocketChannel</strong>，接口统一，实现重用，没有绕来绕去的东西。<br>
        
          <p class="article-more-link">
            <a href="/2018/08/27/Netty之旅（八）Channel/#more">More...</a>
          </p>
        
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-Netty之旅（七）从官方例子展开" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/27/Netty之旅（七）从官方例子展开/">Netty之旅（七）从官方例子展开</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/27/Netty之旅（七）从官方例子展开/" class="article-date">
  <time datetime="2018-08-27T13:03:26.000Z" itemprop="datePublished">2018-08-27</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Netty之旅/">Netty之旅</a>
  </div>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;&emsp;运行example项目中的一个示例（代码基于netty branch 4.1），运行的时候如果报缺少LongObjectHashMap类的错误，进入common项目，运行 mvn clean install。贴一下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来自example中的DiscardServer.class 精简了部分代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = Integer.parseInt(System.getProperty(<span class="string">"port"</span>, <span class="string">"8009"</span>));</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">             .channel(NioServerSocketChannel.class)</span><br><span class="line">             .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">             .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                     ChannelPipeline p = ch.pipeline();</span><br><span class="line">                     p.addLast(<span class="keyword">new</span> DiscardServerHandler());</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">            ChannelFuture f = b.bind(PORT).sync();</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
        
          <p class="article-more-link">
            <a href="/2018/08/27/Netty之旅（七）从官方例子展开/#more">More...</a>
          </p>
        
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-RocketMQ之旅（二）namesrv" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/18/RocketMQ之旅（二）namesrv/">RocketMQ之旅（二）namesrv</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/18/RocketMQ之旅（二）namesrv/" class="article-date">
  <time datetime="2018-08-18T01:21:28.000Z" itemprop="datePublished">2018-08-18</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/RocketMQ之旅/">RocketMQ之旅</a>
  </div>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="NamesrvController"><a href="#NamesrvController" class="headerlink" title="NamesrvController"></a>NamesrvController</h3><p>&emsp;&emsp;namesrv是一个注册中心，每个broker都会向namesrv注册。producer或者consumer根据topic到namesrv获取broker的信息。根据官网Qucik Start来启动namesrv：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; unzip rocketmq-all-4.3.0-source-release.zip</span><br><span class="line">&gt; cd rocketmq-all-4.3.0/</span><br><span class="line">&gt; mvn -Prelease-all -DskipTests clean install -U</span><br><span class="line">&gt; cd distribution/target/apache-rocketmq</span><br><span class="line">&gt; nohup sh bin/mqnamesrv &amp;</span><br><span class="line">&gt; tail -f ~/logs/rocketmqlogs/namesrv.log</span><br><span class="line">The Name Server boot success...</span><br></pre></td></tr></table></figure></p>
<p>查看mqnamesrv脚本，指定启动org.apache.rocketmq.namesrv.NamesrvStartup。进入NamesrvStartup查看代码，是一个main函数，主要分两步：<strong>创建NamesrvController</strong>，<strong>启动NamesrvController</strong>，所以我们重点还是看一下NamesrvController这个类。<br>
        
          <p class="article-more-link">
            <a href="/2018/08/18/RocketMQ之旅（二）namesrv/#more">More...</a>
          </p>
        
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-RocketMQ之旅（一）概述" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/18/RocketMQ之旅（一）概述/">RocketMQ之旅（一）概述</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/18/RocketMQ之旅（一）概述/" class="article-date">
  <time datetime="2018-08-18T01:21:15.000Z" itemprop="datePublished">2018-08-18</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/RocketMQ之旅/">RocketMQ之旅</a>
  </div>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;&emsp;本文基于rocketmq-all-4.3.0。RocketMQ是阿里巴巴开源的分布式消息中间件，使用java语言编写。下面是整个项目模块：<img src="http://ww1.sinaimg.cn/large/639cfad5gy1fu6tj0zaeoj20ke0hwdiw.jpg" alt="Alt text"><br>&emsp;&emsp;简单介绍下项目各个模块的用途：</p>
<ol>
<li><strong>broker</strong> 是整个消息服务的中心，负责收发消息，连接consumer和producer。</li>
<li><strong>client</strong> 集结了consumer和producer</li>
<li><strong>common</strong> 提供通用基础方法给其他模块调用</li>
<li><strong>dev</strong> 是一个版本控制脚本不用管</li>
<li><strong>distribution</strong> 提供了一些部署的脚本</li>
<li><strong>filter</strong> 过滤器，提供SQL92标准的过滤方式</li>
<li><strong>logappender</strong> 日志模块</li>
<li><strong>logging</strong> 也是日志</li>
<li><strong>namesrv</strong> 注册中心，管理broker和topic信息</li>
<li><strong>openmessaging</strong> openmessaging是由阿里巴巴发起的分布式消息领域的国际标准，这个包主要提供openmessaging标准的部分实现</li>
<li><strong>remoting</strong> 是一个通用的网络通信基础模块，基于netty实现</li>
<li><strong>srvutil</strong> 工具包，里面只有三个类</li>
<li><strong>store</strong> 消息相关存储服务</li>
<li><strong>style</strong> 统一代码风格不用管</li>
<li><strong>test</strong> 测试相关</li>
<li><strong>tools</strong> 工具类，提供一些后台管理的工具</li>
</ol>
<p>&emsp;&emsp;模块众多，重点还是关注<strong>broker</strong>、<strong>client</strong>、<strong>namesrv</strong>、<strong>remoting</strong>、<strong>store</strong>这几个模块，这些也是一个消息中间件的核心模块。</p>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-Netty之旅（六）ByteBuf内存管理之PoolArena" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/08/Netty之旅（六）ByteBuf内存管理之PoolArena/">Netty之旅（六）ByteBuf内存管理之PoolArena</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/08/Netty之旅（六）ByteBuf内存管理之PoolArena/" class="article-date">
  <time datetime="2018-08-08T13:28:46.000Z" itemprop="datePublished">2018-08-08</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Netty之旅/">Netty之旅</a>
  </div>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;&emsp;<a href="../Netty之旅（五）ByteBuf内存管理之PoolSubpage">Netty之旅（五）ByteBuf内存管理之PoolSubpage</a>中描述PoolSubpage分配内存的时候，allocateSubpage方法开头就会调用PoolArena：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">allocateSubpage</span><span class="params">(<span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">    PoolSubpage&lt;T&gt; head = arena.findSubpagePoolHead(normCapacity);</span><br><span class="line">    ......（省略）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者在<a href="../Netty之旅（三）ByteBuf内存管理">Netty之旅（三）ByteBuf内存管理</a>中，PooledByteBufAllocator来分配堆内存：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected ByteBuf newHeapBuffer(int initialCapacity, int maxCapacity) &#123;</span><br><span class="line">    PoolThreadCache cache = threadCache.get();</span><br><span class="line">    PoolArena&lt;byte[]&gt; heapArena = cache.heapArena;</span><br><span class="line">    ......（省略）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
        
          <p class="article-more-link">
            <a href="/2018/08/08/Netty之旅（六）ByteBuf内存管理之PoolArena/#more">More...</a>
          </p>
        
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-Netty之旅（五）ByteBuf内存管理之PoolSubpage" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/08/Netty之旅（五）ByteBuf内存管理之PoolSubpage/">Netty之旅（五）ByteBuf内存管理之PoolSubpage</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/08/Netty之旅（五）ByteBuf内存管理之PoolSubpage/" class="article-date">
  <time datetime="2018-08-08T13:28:16.000Z" itemprop="datePublished">2018-08-08</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Netty之旅/">Netty之旅</a>
  </div>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="PoolChunk分配小内存过程"><a href="#PoolChunk分配小内存过程" class="headerlink" title="PoolChunk分配小内存过程"></a>PoolChunk分配小内存过程</h3><p>&emsp;&emsp;1. 在Netty中内存以页为最小单位划分，假设分配2048KB大小的内存，如果使用PoolChunk直接分配一页，那真是太浪费了。参照Slab机制，Netty将一页内存进行更细致化的管理，使用PoolSubpage来分配小于一页的内存。<br>&emsp;&emsp;2. PoolChunk内部维护一个PoolSubpage的数组subpages，数组大小为1 &lt;&lt; maxOrder即默认为2048，相当于PoolChunk二叉树的叶子节点数量。<br>&emsp;&emsp;3. PoolSubpage每次分配内存的时候，只会去二叉树的叶子节点搜寻，当某一个节点被选中时，会根据节点的id，找到subpages数组种对应的PoolSubpage实例，如果该实例为空，则新建一个，然后使用PoolSubpage进行内存分配。看一下PoolChunk的内存分配入口<strong>allocateSubpage</strong>方法：<br>
        
          <p class="article-more-link">
            <a href="/2018/08/08/Netty之旅（五）ByteBuf内存管理之PoolSubpage/#more">More...</a>
          </p>
        
      

      
        
    </div>
  </div>
  
</article>



  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</section>
        <aside id="sidebar">
  <nav class="menus">
  	<ul>
  		<li><a href="/"><i class="icon icon-home"></i></a></li>
  		
			<li><a href="/archives"><i class="icon icon-fenlei"></i></a></li>
  		
  		
			<li><a href="/tags"><i class="icon icon-tag"></i></a></li>
  		
  		
  			<li><a href="https://github.com/hejianxian" target="_blank"><i class="icon icon-github"></i></a></li>
  		
  	</ul>
  </nav>
  <a id="go-top" href="#"><i class="icon icon-up"></i></a>
</aside>

      </div>
      <footer id="footer">
  
	<div id="footer-info" class="inner">
	  &copy; 2019 matrix22 
	  - Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
	  - Theme <a href="https://github.com/hejianxian/hexo-theme-jane/" target="_blank">Jane</a>
	</div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/tags" class="mobile-nav-link">Tag</a>
  
    <a href="https://github.com/hejianxian" class="mobile-nav-link">Github</a>
  
</nav>
    

<script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>